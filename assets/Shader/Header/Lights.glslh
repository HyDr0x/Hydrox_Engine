#define PI 3.14159265359f
#define DIRECTIONAL_LIGHT_POSITION 8388608

#include "LightData.glslh"

float calculateBRDF(in vec3 camDir, in vec3 lightDir, in vec3 normal, in float diffuseStrength, in float specularStrength, in float specularExponent)
{
	float diffuse = diffuseStrength / PI;
	
	//vec3 reflectRay = reflect(-lightDir, normal);
	//float specular = ((specularExponent + 2.0f) / (2.0f * PI)) * specularStrength * pow(max(dot(reflectRay, camDir), 0.0f), specularExponent);
	
	vec3 halfVector = (lightDir + camDir) / length(lightDir + camDir);
	float specular = ((specularExponent + 8.0f) / (8.0f * PI)) * specularStrength * pow(max(dot(halfVector, normal), 0.0f), specularExponent);
	
	return diffuse + specular;
}

float calculateLightIntensity(LightData light, const vec3 worldPos, const vec3 normal, const vec4 material)
{
	if(light.position.x == DIRECTIONAL_LIGHT_POSITION)//DIRECTIONAL LIGHT
	{
		vec3 lightDir = normalize(-light.direction.xyz);
		float seeable = max(dot(lightDir, normal), 0.0f);
		
		float brdf = calculateBRDF(normalize(eyePos.xyz - worldPos), lightDir, normal, material.x, material.y, material.w);
		
		return light.luminousFlux * seeable * brdf;
	}
	else if(light.direction.xyz == vec3(0.0f))//POINTLIGHT
	{
		vec3 lightDir = light.position.xyz - worldPos;
		float distance = length(lightDir);
		lightDir = normalize(lightDir);
		float seeable = max(dot(lightDir, normal), 0.0f);
		
		float brdf = calculateBRDF(normalize(eyePos.xyz - worldPos), lightDir, normal, material.x, material.y, material.w);
		
		float attenuation = 1.0f /(light.constAttenuation + light.linearAttenuation * distance + light.quadricAttenuation * distance * distance);
		
		return attenuation * light.luminousFlux * seeable * brdf;
	}
	else//SPOTLIGHT
	{
		vec3 lightDir = light.position.xyz - worldPos;
		float distance = length(lightDir);
		lightDir = normalize(lightDir);
		float seeable = max(dot(lightDir, normal), 0.0f);
		
		float brdf = calculateBRDF(normalize(eyePos.xyz - worldPos), lightDir, normal, material.x, material.y, material.w);
		
		float attenuation = 1.0f / (light.constAttenuation + light.linearAttenuation * distance + light.quadricAttenuation * distance * distance);
		float spotLightAngle = max(dot(lightDir, normalize(light.direction.xyz)), 0.0f);
		float spotAttenuation = step(light.direction.w, spotLightAngle) * clamp(pow(spotLightAngle, light.position.w), 0.0f, 1.0f);
		
		return spotAttenuation * attenuation * light.luminousFlux * seeable * brdf;
	}
}
