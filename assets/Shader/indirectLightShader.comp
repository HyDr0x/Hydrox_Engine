#version 440 core

#define WORKGROUPSIZE 64
#define PI 3.14159265359f
#define Ep 0.0001f

#include "Header/LightData.glslh"
#include "Header/IndirectLightData.glslh"
#include "Header/CacheData.glslh"
#include "Header/CameraUBO.glslh"

layout(location = 0) uniform sampler2DArray indirectLightPosSampler;
layout(location = 1) uniform sampler2DArray indirectLightNormalSampler;
layout(location = 2) uniform sampler2DArray indirectLightLuminousFluxSampler;

layout(location = 3) uniform uint indirectLightNumberX;
layout(location = 4) uniform uint indirectLightNumberY;
layout(location = 5) uniform uint indirectLightNumberZ;

layout(location = 6) uniform uint cacheNumber;

layout(location = 7) uniform uint unusedIndirectLightsNumber;

layout(std430, binding = 0) buffer globalCacheBuffer
{
	CacheData caches[];
};

layout(std430, binding = 1) buffer zBuffer
{
	uint zValues[];
};

layout(std430, binding = 2) buffer indirectLightDataBuffer
{
	IndirectLightData indirectLight[];
};

layout(local_size_x = WORKGROUPSIZE) in;

void main()
{
	uint idx = gl_GlobalInvocationID.x;

	uint cachesPerThread = max(cacheNumber / (WORKGROUPSIZE * gl_NumWorkGroups.x), 1);
	uint cacheOffset = idx * cachesPerThread;
	
	if(cacheOffset >= cacheNumber)
	{
		return;
	}
	
	uint lightNumber = indirectLightNumberX * indirectLightNumberY * indirectLightNumberZ;
	
	for(uint i = 0; i < cachesPerThread; i++)
	{
		uint cacheIndex = cacheOffset + i;
		
		if(zValues[cacheIndex] == 0)
		{
			continue;
		}
		
		vec3 Lod = vec3(0.0f), Xpd = vec3(0.0f);
		vec3 Log = vec3(0.0f), Xpg = vec3(0.0f);
		
		float Wgesd = 0.0f;
		float Wgesg = 0.0f;
		
		CacheData cache = caches[cacheIndex];
		float frd = cache.position.w / PI;
		float frg = cache.normal.w * (cache.specularExponent.x + 2.0f) / (2.0f * PI);
		
		vec3 camDir = normalize(eyePos.xyz - cache.position.xyz);
		
		for(uint j = 0; j < lightNumber; j += unusedIndirectLightsNumber)
		{/*
			vec3 texCoords;
			texCoords.x = float(j % indirectLightNumberX) / float(indirectLightNumberX);
			texCoords.y = float((j % (indirectLightNumberX * indirectLightNumberY)) / float(indirectLightNumberX)) / float(indirectLightNumberY);
			texCoords.z = float(j / float(indirectLightNumberX * indirectLightNumberY)) / float(indirectLightNumberZ);
			*/
			ivec3 texCoords;
			texCoords.x = int(j % indirectLightNumberX);
			texCoords.y = int((j % (indirectLightNumberX * indirectLightNumberY)) / float(indirectLightNumberX));
			texCoords.z = int(j / float(indirectLightNumberX * indirectLightNumberY));
			
			vec4 lightPos = texelFetch(indirectLightPosSampler, texCoords, 0);
			
			if(lightPos.w == 1.0f) continue;
			
			vec4 lightNormalArea = texelFetch(indirectLightNormalSampler, texCoords, 0);
			
			vec3 lightNormal = normalize(lightNormalArea.xyz * 2.0f - 1.0f);
			float lightArea = lightNormalArea.w;
			
			vec3 luminousFlux = texelFetch(indirectLightLuminousFluxSampler, texCoords, 0).rgb;
			
			vec3 lightDir = lightPos.xyz - cache.position.xyz;
			float quadDistance = dot(lightDir, lightDir);
			lightDir = normalize(lightDir);
			
			vec3 reflectRay = reflect(-lightDir, cache.normal.xyz);
			float reflAngle = max(pow(dot(reflectRay, camDir), cache.specularExponent.x), 0.00001f);
			
			float F = max(dot(lightNormal.xyz, normalize(cache.position.xyz - lightPos.xyz)) * dot(cache.normal.xyz, lightDir), 0) / (lightArea + PI * quadDistance);
			
			float Wd = Ep + F;
			float Wg = Ep + reflAngle * F;
			
			Xpd += Wd * lightPos.xyz;
			Xpg += Wg * lightPos.xyz;
			
			Lod += luminousFlux * frd * F;
			Log += luminousFlux * frg * reflAngle * F;
			
			Wgesd += Wd;
			Wgesg += Wg;
		}
		
		Xpd /= Wgesd;
		Xpg /= Wgesg;
		
		vec3 lightDirD = Xpd - cache.position.xyz;
		float lightAngleD = max(dot(cache.normal.xyz, normalize(lightDirD)), 0.1f);
		
		indirectLight[2 * cacheIndex].position.xyz = Xpd;
		indirectLight[2 * cacheIndex].luminousFlux.xyz = (4.0f * PI * Lod * dot(lightDirD, lightDirD)) / (frd * lightAngleD);
		
		vec3 lightDirG = Xpg - cache.position.xyz;
		float lightQuadDistance = dot(lightDirG, lightDirG);
		lightDirG = normalize(lightDirG);
		float reflAngleG = max(pow(dot(reflect(-lightDirG, cache.normal.xyz), camDir), cache.specularExponent.x), 0.1f);
		float lightAngleG = max(dot(lightDirG, cache.normal.xyz), 0.1f);
		
		indirectLight[2 * cacheIndex + 1].position.xyz = Xpg;
		indirectLight[2 * cacheIndex + 1].luminousFlux.xyz = (4.0f * PI * Log * lightQuadDistance) / (frg * reflAngleG * lightAngleG);
	}
}