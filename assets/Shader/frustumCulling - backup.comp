#version 430 core

#define WORKGROUPSIZE 256

layout(std140, binding = 0) uniform cameraParameters
{
	mat4 viewMatrix;
	mat4 projectionMatrix;
	mat4 viewProjectionMatrix;
	vec4 eyePos;
};

layout(std430, binding = 0) buffer transformBuffer
{
	mat4 transformMatrices[];
};

layout(std430, binding = 1) buffer bbMinBuffer
{
	vec4 bbMin[];
};

layout(std430, binding = 2) buffer bbMaxBuffer
{
	vec4 bbMax[];
};

layout(std430, binding = 3) buffer culledAABBBuffer
{
	uint culledAABB[];
};

layout(std430, binding = 4) buffer transformedAABBBuffer
{
	vec4 AABBPositions[];
};


layout(location = 1) uniform uint AABBNumber;

layout(local_size_x = WORKGROUPSIZE) in;

void main()
{
	uint idx = gl_GlobalInvocationID.x;

	uint bboxesPerThread = max(AABBNumber / (WORKGROUPSIZE * gl_NumWorkGroups.x), 1);

	if(idx * bboxesPerThread >= AABBNumber)
	{
		return;
	}

	for(unsigned int i = 0; i < bboxesPerThread; i++)
	{
		uint index = idx * bboxesPerThread + i;

		mat4 MVP = viewProjectionMatrix * transformMatrices[index];

		vec4 plane[6];
		
		plane[0] = vec4(MVP[0][3] + MVP[0][0], MVP[1][3] + MVP[1][0], MVP[2][3] + MVP[2][0], MVP[3][3] + MVP[3][0]);//left plane
		plane[1] = vec4(MVP[0][3] - MVP[0][0], MVP[1][3] - MVP[1][0], MVP[2][3] - MVP[2][0], MVP[3][3] - MVP[3][0]);//right plane

		plane[2] = vec4(MVP[0][3] + MVP[0][1], MVP[1][3] + MVP[1][1], MVP[2][3] + MVP[2][1], MVP[3][3] + MVP[3][1]);//bottom plane
		plane[3] = vec4(MVP[0][3] - MVP[0][1], MVP[1][3] - MVP[1][1], MVP[2][3] - MVP[2][1], MVP[3][3] - MVP[3][1]);//top plane

		plane[4] = vec4(MVP[0][3] + MVP[0][2], MVP[1][3] + MVP[1][2], MVP[2][3] + MVP[2][2], MVP[3][3] + MVP[3][2]);//near plane
		plane[5] = vec4(MVP[0][3] - MVP[0][2], MVP[1][3] - MVP[1][2], MVP[2][3] - MVP[2][2], MVP[3][3] - MVP[3][2]);//far plane
		/*
		plane[0] = vec4(MVP[3] + MVP[0]);//left plane
		plane[1] = vec4(MVP[3] - MVP[0]);//right plane

		plane[2] = vec4(MVP[3] + MVP[1]);//bottom plane
		plane[3] = vec4(MVP[3] - MVP[1]);//top plane

		plane[4] = vec4(MVP[3] + MVP[2]);//near plane
		plane[5] = vec4(MVP[3] - MVP[2]);//far plane*/

		vec3 bbSides = bbMax[index].xyz - bbMin[index].xyz;

		vec3 bbSideX = vec3(bbSides.x, 0, 0);
		vec3 bbSideY = vec3(0, bbSides.y, 0);
		vec3 bbSideZ = vec3(0, 0, bbSides.z);
		vec3 bbPosition = bbMin[index].xyz;

		vec4 bbPositions[8];
		
		bbPositions[0] = vec4(bbPosition, 1);
		bbPositions[1] = vec4(bbPosition + bbSideX, 1);
		bbPositions[2] = vec4(bbPosition + bbSideY, 1);
		bbPositions[3] = vec4(bbPosition + bbSideZ, 1);

		bbPositions[4] = vec4(bbPosition + bbSideX + bbSideY, 1);
		bbPositions[5] = vec4(bbPosition + bbSideX + bbSideZ, 1);
		bbPositions[6] = vec4(bbPosition + bbSideY + bbSideZ, 1);
		bbPositions[7] = vec4(bbPosition + bbSideX + bbSideY + bbSideZ, 1);

		unsigned int inside = 0;

		for(unsigned int j = 0; j < 6; j++)
		{
			for(unsigned int k = 0; k < 8; k++)
			{
				if(dot(bbPositions[k], plane[j]) > 0)
				{
					inside++;
					break;
				}
			}
		}

		culledAABB[index] = uint(inside != 6);
	}
}