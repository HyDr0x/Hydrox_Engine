#version 440 core

#define HALFRESX
#define HALFRESY
#define RESOLUTIONDIVISOR

#define VERTEXTILEMULTI
#define VERTEXTILESIZE
#define MULTVERTEXTILESIZE (VERTEXTILEMULTI * VERTEXTILESIZE)
#define PIXELTILESIZE (RESOLUTIONDIVISOR * MULTVERTEXTILESIZE)

#define GIMAPWORKGROUPSIZE

#define PI 3.14159265359
#define INT32_MAX 2147483647

#include "../../HydroxShader/include/Shader/Shaderincludes/CameraUBO.glslh"
#include "../../HydroxShader/include/Shader/Shaderincludes/CacheData.glslh"
#include "../../HydroxShader/include/Shader/Shaderincludes/IndirectLightData.glslh"
#include "../../HydroxShader/include/Shader/Shaderincludes/Encodings.glslh"
#include "../../HydroxShader/include/Shader/Shaderincludes/MaterialConversion.glslh"

layout(location = 0) uniform sampler2D gBufferDepthSampler;
layout(location = 1) uniform sampler2D gBufferNormalSampler;
layout(location = 2) uniform sampler2D gBufferMaterialSampler;

layout(rgba16f, binding = 0) writeonly uniform image2D indirectLightImage;
layout(r32ui, binding = 1) readonly uniform uimage2D vertexAtomicIndexSampler;
layout(rgba32f, binding = 2) readonly uniform image2D vertexPositionImage;
layout(rgba32f, binding = 3) readonly uniform image2D vertexNormalImage;

layout(std430, binding = 0) buffer specularCachePositionBuffer
{
	vec4 specularCachePositions[];
};

layout(std430, binding = 1) buffer specularCacheNormalMaterialBuffer
{
	vec4 specularCacheNormalMaterial[];
};

layout(std430, binding = 2) buffer proxyLightPositionBuffer
{
	vec4 proxyLightPosition[];
};

layout(std430, binding = 3) buffer proxyLightLuminousFluxBuffer
{
	vec4 proxyLightLuminousFlux[];
};

layout(std430, binding = 4) buffer specularCacheIndicesBuffer
{
	uint specularCacheIndices[];
};

layout(local_size_x = GIMAPWORKGROUPSIZE) in;

shared vec3 groupVertexPositions[MULTVERTEXTILESIZE * MULTVERTEXTILESIZE];
shared vec3 groupVertexNormals[MULTVERTEXTILESIZE * MULTVERTEXTILESIZE];
shared uint groupCacheIndices[8 * MULTVERTEXTILESIZE * MULTVERTEXTILESIZE];

void main()
{
	const uint idx = gl_GlobalInvocationID.x;
	const uint localIDx = gl_LocalInvocationIndex;
	
	const uvec2 vertexTileNumber = (uvec2(HALFRESX, HALFRESY) + uvec2(MULTVERTEXTILESIZE - 1)) / MULTVERTEXTILESIZE;
	const ivec2 vertexTilePixelNumber = ivec2(vertexTileNumber) * MULTVERTEXTILESIZE;
	const uint vertexTilesPerGroup = (vertexTileNumber.x * vertexTileNumber.y + gl_NumWorkGroups.x - 1) / gl_NumWorkGroups.x;
	const uint vertexTileStartIndex = gl_WorkGroupID.x * vertexTilesPerGroup;
	const uint vertexTileEndIndex = vertexTileStartIndex + vertexTilesPerGroup;

	const ivec2 pixelTileNumber = (ivec2(width, height) + ivec2(PIXELTILESIZE - 1)) / PIXELTILESIZE;
	const ivec2 pixelTilePixelNumber = pixelTileNumber * PIXELTILESIZE;
	const uint pixelTilesPerThread = (pixelTileNumber.x * pixelTileNumber.y + gl_NumWorkGroups.x - 1) / gl_NumWorkGroups.x;
	const uint pixelTileStartIndex = gl_WorkGroupID.x * pixelTilesPerThread;
	const uint pixelTileEndIndex = pixelTileStartIndex + pixelTilesPerThread;
	
	const uint pixelNumber = PIXELTILESIZE * PIXELTILESIZE;
	const uint pixelsPerThread = (pixelNumber + GIMAPWORKGROUPSIZE - 1) / GIMAPWORKGROUPSIZE;
	const uint pixelStartIndex = localIDx * pixelsPerThread;
	const uint pixelEndIndex = pixelStartIndex + pixelsPerThread;
	
	for(uint i = pixelTileStartIndex; i < pixelTileEndIndex; i++)
	{
		ivec2 pixelBlockCoord = ivec2(mod(i, pixelTileNumber.x), i / pixelTileNumber.x);
	
		uint proxyPixelIndexOffsets[8 * pixelsPerThread];
		float proxyPixelIndexWeights[pixelsPerThread];
	
		uint pixelIndex = 0;
		for(uint j = pixelStartIndex; j < pixelEndIndex; j++, pixelIndex++)
		{
			ivec2 texCoord = PIXELTILESIZE * pixelBlockCoord + ivec2(mod(j, PIXELTILESIZE), j / PIXELTILESIZE);
			vec2 texCoordNormalized = vec2(texCoord.x / float(width), texCoord.y / float(height));
		
			if(texCoord.x > width || texCoord.y > height) 
			{
				break;
			}
			
			vec4 pixelPosition = vec4(texCoordNormalized, texelFetch(gBufferDepthSampler, texCoord, 0).r, 1.0);
			pixelPosition.xyz = pixelPosition.xyz * 2.0 - 1.0;
			pixelPosition = invViewProjectionMatrix * pixelPosition;
			pixelPosition.xyz /= pixelPosition.w;
			
			vec3 pixelNormal = normalize(texelFetch(gBufferNormalSampler, texCoord, 0).xyz * 2.0 - 1.0);
			vec4 pixelMaterial = GGXToBlinnPhong(texelFetch(gBufferMaterialSampler, texCoord, 0));

			/*
			for(uint k = 0; k < 8; k++)
			{
				proxyPixelIndexOffsets[8 * pixelIndex + k] = INT32_MAX;
			}*/
			proxyPixelIndexWeights[pixelIndex] = INT32_MAX;
			
			for(uint k = 0; k < 9; k++)
			{
				ivec2 vertexBlockCoord = pixelBlockCoord + ivec2(mod(k, 3), k / 3) - ivec2(1);
				
				if(vertexBlockCoord.x >= vertexTileNumber.x || vertexBlockCoord.y >= vertexTileNumber.y) continue;
				
				const uint vertexNumber = imageLoad(vertexAtomicIndexSampler, vertexBlockCoord).r;
				
				const uint verticesPerThread = (vertexNumber + GIMAPWORKGROUPSIZE - 1) / GIMAPWORKGROUPSIZE;
				const uint vertexStartIndex = localIDx * verticesPerThread;
				const uint vertexEndIndex = vertexStartIndex + verticesPerThread;
				for(uint l = vertexStartIndex; l < vertexEndIndex; l++)
				{
					if(l < vertexNumber)
					{
						ivec2 proxyTexCoord = MULTVERTEXTILESIZE * vertexBlockCoord + ivec2(mod(l, MULTVERTEXTILESIZE), l / MULTVERTEXTILESIZE);
					
						for(uint m = 0; m < 8; m++)
						{
							groupCacheIndices[l * 8 + m] = specularCacheIndices[8 * (proxyTexCoord.x + proxyTexCoord.y * vertexTilePixelNumber.x) + m];
						}
					
						groupVertexPositions[l] = imageLoad(vertexPositionImage, proxyTexCoord).xyz;
						groupVertexNormals[l] = normalize(imageLoad(vertexNormalImage, proxyTexCoord).xyz);
					}
				}
				
				memoryBarrierShared();
				barrier();

				uint pixelIndexGroupOffset = INT32_MAX;
				for(uint l = 0; l < vertexNumber; l++)
				{
					float weight = distance(pixelPosition.xyz, groupVertexPositions[l]) / max(dot(pixelNormal, groupVertexNormals[l]), 0.0);
					if(proxyPixelIndexWeights[pixelIndex] > weight)
					{
						proxyPixelIndexWeights[pixelIndex] = weight;
						pixelIndexGroupOffset = 8 * l;
					}
				}
				
				if(pixelIndexGroupOffset != INT32_MAX)
				{
					for(uint m = 0; m < 8; m++)
					{
						proxyPixelIndexOffsets[pixelIndex * 8 + m] = groupCacheIndices[pixelIndexGroupOffset + m];
					}
				}
				
				memoryBarrierShared();
				barrier();
			}
		}
		
		pixelIndex = 0;
		for(uint j = pixelStartIndex; j < pixelEndIndex; j++, pixelIndex++)
		{
			ivec2 texCoord = PIXELTILESIZE * pixelBlockCoord + ivec2(mod(j, PIXELTILESIZE), j / PIXELTILESIZE);
			vec2 texCoordNormalized = vec2(texCoord.x / float(width), texCoord.y / float(height));
			
			vec4 pixelPosition = vec4(texCoordNormalized, texelFetch(gBufferDepthSampler, texCoord, 0).r, 1.0);
			pixelPosition.xyz = pixelPosition.xyz * 2.0 - 1.0;
			pixelPosition = invViewProjectionMatrix * pixelPosition;
			pixelPosition.xyz /= pixelPosition.w;
			
			vec3 pixelNormal = normalize(texelFetch(gBufferNormalSampler, texCoord, 0).xyz * 2.0 - 1.0);
			vec4 pixelMaterial = GGXToBlinnPhong(texelFetch(gBufferMaterialSampler, texCoord, 0));
			
			float dmax = 0.0;
			for(uint k = 0; k < 8; k++)
			{
				if(proxyPixelIndexOffsets[pixelIndex * 8 + k] < INT32_MAX)
				{
					vec3 diff = pixelPosition.xyz - specularCachePositions[proxyPixelIndexOffsets[pixelIndex * 8 + k]].xyz;
					dmax = max(dmax, dot(diff, diff));
				}
			}
			
			vec3 camDir = normalize(eyePos.xyz - pixelPosition.xyz);
			vec3 reflectCamDir = reflect(-camDir, pixelNormal);
			
			dmax = sqrt(max(dmax, 0.0));
			
			vec3 Xpd = vec3(0.0), phiPD = vec3(0.0);
			vec3 Xpg = vec3(0.0), phiPG = vec3(0.0);
			
			float wGesD = 0.0, cacheProxyMinDistanceD = 0.0;
			float wGesG = 0.0, cacheProxyMinDistanceG = 0.0;
			
			for(uint k = 0; k < 8; k++)
			{
				uint cacheIndex = proxyPixelIndexOffsets[pixelIndex * 8 + k];
				if(cacheIndex < INT32_MAX)
				{
					CacheData cache;
					cache.position = specularCachePositions[cacheIndex];
					cache.normal = vec4(normalize(decodeNormal(specularCacheNormalMaterial[cacheIndex].xy)), 0.0);
					
					float dir = max(1.0 - distance(pixelPosition.xyz, cache.position.xyz) / dmax, 0.01);//without the max the last cache getting always rejected, cause dir == 0.0
						
					float wd = dir * sqrt(max(dot(cache.normal.xyz, pixelNormal), 0));
						
					vec3 camCacheDir = normalize(eyePos.xyz - cache.position.xyz);
					float wg = dir * sqrt(max(dot(reflect(-camCacheDir, cache.normal.xyz), reflectCamDir), 0.0));
					
					IndirectLightData indirectLightD;
					indirectLightD.position = proxyLightPosition[2 * cacheIndex];
					indirectLightD.luminousFlux = proxyLightLuminousFlux[2 * cacheIndex];
					
					IndirectLightData indirectLightG;
					indirectLightG.position = proxyLightPosition[2 * cacheIndex + 1];
					indirectLightG.luminousFlux = proxyLightLuminousFlux[2 * cacheIndex + 1];
					
					Xpd += wd * indirectLightD.position.xyz;
					Xpg += wg * indirectLightG.position.xyz;
					
					phiPD += wd * indirectLightD.luminousFlux.xyz;
					phiPG += wg * indirectLightG.luminousFlux.xyz;

					wGesD += wd;
					wGesG += wg;
					
					cacheProxyMinDistanceD += wd * indirectLightD.position.w;
					cacheProxyMinDistanceG += wg * indirectLightG.position.w;
				}
			}
			
			Xpd = wGesD > 0 ? Xpd / wGesD : vec3(0);
			Xpg = wGesG > 0 ? Xpg / wGesG : vec3(0);
			
			phiPD = wGesD > 0 ? phiPD / wGesD : vec3(0);
			phiPG = wGesG > 0 ? phiPG / wGesG : vec3(0);

			cacheProxyMinDistanceD = wGesD > 0 ? cacheProxyMinDistanceD / wGesD : 0;
			cacheProxyMinDistanceG = wGesG > 0 ? cacheProxyMinDistanceG / wGesG : 0;
			
			vec3 lightDirD = Xpd - pixelPosition.xyz;
			//float lengthD = max(dot(lightDirD, lightDirD), cacheProxyMinDistanceD * cacheProxyMinDistanceD);
			float lengthD = max(length(lightDirD), cacheProxyMinDistanceD);
			lightDirD = normalize(lightDirD);
			float frd = pixelMaterial.x * max(dot(lightDirD, pixelNormal), 0.0);
			
			vec3 lightDirG = Xpg - pixelPosition.xyz;
			//float lengthG = max(dot(lightDirG, lightDirG), dot(cacheProxyMinDistanceG, cacheProxyMinDistanceG));
			float lengthG = max(length(lightDirG), cacheProxyMinDistanceG);
			lightDirG = normalize(lightDirG);
			float frg = pixelMaterial.y * max(dot(lightDirG, pixelNormal), 0.0) * pow(max(dot(reflect(-lightDirG, pixelNormal), camDir), 0.0), pixelMaterial.w);

			vec4 luminousFlux;
			//luminousFlux = vec4(pixelNormal, 1);
			//luminousFlux = vec4(vec3(frd * 0.1), 1);
			//luminousFlux = vec4(0.05 * vec3(lengthG), 1);
			//luminousFlux = vec4(0.1 * Xpg, 1);
			//luminousFlux = vec4(0.01 * phiPD, 1);
			//luminousFlux = vec4(max((frd * phiPD) / (4.0f * PI * lengthD), 0.0), 0.0);
			//luminousFlux = vec4(max((frg * phiPG) / (4.0 * PI * lengthG), 0.0), 1.0);
			luminousFlux = vec4(max((frd * phiPD) / (4.0f * PI * lengthD), 0.0) + max((frg * phiPG) / (4.0 * PI * lengthG), 0.0), 1.0);
			//luminousFlux = vec4(1, 0, 0, 0);
			
			imageStore(indirectLightImage, texCoord, luminousFlux);
		}
	}
}