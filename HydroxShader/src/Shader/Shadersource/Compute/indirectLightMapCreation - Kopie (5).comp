#version 440 core

#define HALFRESX
#define HALFRESY
#define RESOLUTIONDIVISOR

#define WORKGROUPSIZE 64

#define VERTEXTILEMULTI
#define VERTEXTILESIZE
#define MULTVERTEXTILESIZE (VERTEXTILEMULTI * VERTEXTILESIZE)
#define PIXELTILESIZE (RESOLUTIONDIVISOR * MULTVERTEXTILESIZE)
#define PI 3.14159265359
#define INT32_MAX 2147483647

#include "../../HydroxShader/include/Shader/Shaderincludes/CameraUBO.glslh"
#include "../../HydroxShader/include/Shader/Shaderincludes/CacheData.glslh"
#include "../../HydroxShader/include/Shader/Shaderincludes/IndirectLightData.glslh"
#include "../../HydroxShader/include/Shader/Shaderincludes/Encodings.glslh"
#include "../../HydroxShader/include/Shader/Shaderincludes/MaterialConversion.glslh"

layout(location = 0) uniform sampler2D gBufferDepthSampler;
layout(location = 1) uniform sampler2D gBufferNormalSampler;
layout(location = 2) uniform sampler2D gBufferMaterialSampler;

layout(rgba16f, binding = 0) writeonly uniform image2D indirectLightImage;
layout(r32ui, binding = 1) readonly uniform uimage2D vertexAtomicIndexSampler;
layout(rgba32f, binding = 2) readonly uniform image2D vertexPositionImage;
layout(rgba32f, binding = 3) readonly uniform image2D vertexNormalImage;

layout(std430, binding = 0) buffer specularCachePositionBuffer
{
	vec4 specularCachePositions[];
};

layout(std430, binding = 1) buffer specularCacheNormalMaterialBuffer
{
	vec4 specularCacheNormalMaterial[];
};

layout(std430, binding = 2) buffer proxyLightPositionBuffer
{
	vec4 proxyLightPosition[];
};

layout(std430, binding = 3) buffer proxyLightLuminousFluxBuffer
{
	vec4 proxyLightLuminousFlux[];
};

layout(std430, binding = 4) buffer specularCacheIndicesBuffer
{
	uint specularCacheIndices[];
};

layout(local_size_x = WORKGROUPSIZE) in;

shared vec3 groupVertexPositions[MULTVERTEXTILESIZE * MULTVERTEXTILESIZE];
shared vec3 groupVertexNormals[MULTVERTEXTILESIZE * MULTVERTEXTILESIZE];
shared uint groupCacheIndices[8 * MULTVERTEXTILESIZE * MULTVERTEXTILESIZE];

void main()
{
	const uint idx = gl_GlobalInvocationID.x;
	const uint localIDx = gl_LocalInvocationIndex;
	
	const uvec2 vertexTileNumber = (uvec2(HALFRESX, HALFRESY) + uvec2(MULTVERTEXTILESIZE - 1)) / MULTVERTEXTILESIZE;

	const ivec2 vertexTilePixelNumber = ivec2(vertexTileNumber) * MULTVERTEXTILESIZE;
	const uint vertexTilesPerGroup = (vertexTileNumber.x * vertexTileNumber.y + gl_NumWorkGroups.x - 1) / gl_NumWorkGroups.x;
	const uint vertexTileStartIndex = gl_WorkGroupID.x * vertexTilesPerGroup;
	const uint vertexTileEndIndex = vertexTileStartIndex + vertexTilesPerGroup;

	for(uint i = vertexTileStartIndex; i < vertexTileEndIndex; i++)
	{
		if(i >= vertexTileNumber.x * vertexTileNumber.y) continue;
	
		ivec2 vertexBlockCoord = ivec2(mod(i, vertexTileNumber.x), i / vertexTileNumber.x);
		
		const uint vertexNumber = imageLoad(vertexAtomicIndexSampler, vertexBlockCoord).r;
		
		const uint verticesPerThread = (vertexNumber + WORKGROUPSIZE - 1) / WORKGROUPSIZE;
		const uint vertexStartIndex = localIDx * verticesPerThread;
		const uint vertexEndIndex = vertexStartIndex + verticesPerThread;
		for(uint j = vertexStartIndex; j < vertexEndIndex; j++)
		{
			if(j < vertexNumber)
			{
				ivec2 texCoord = MULTVERTEXTILESIZE * vertexBlockCoord + ivec2(mod(j, MULTVERTEXTILESIZE), j / MULTVERTEXTILESIZE);
			
				for(uint k = 0; k < 8; k++)
				{
					groupCacheIndices[j * 8 + k] = specularCacheIndices[8 * (texCoord.x + texCoord.y * vertexTilePixelNumber.x) + k];
				}
			
				groupVertexPositions[j] = imageLoad(vertexPositionImage, texCoord).xyz;
				groupVertexNormals[j] = normalize(imageLoad(vertexNormalImage, texCoord).xyz);
			}
		}
		
		memoryBarrierShared();
		barrier();

		const uint pixelNumber = PIXELTILESIZE * PIXELTILESIZE;
		const uint pixelsPerThread = (pixelNumber + WORKGROUPSIZE - 1) / WORKGROUPSIZE;
		const uint pixelStartIndex = localIDx * pixelsPerThread;
		const uint pixelEndIndex = pixelStartIndex + pixelsPerThread;
				
		for(uint j = pixelStartIndex; j < pixelEndIndex; j++)
		{
			ivec2 texCoord = PIXELTILESIZE * vertexBlockCoord + ivec2(mod(j, PIXELTILESIZE), j / PIXELTILESIZE);
			vec2 texCoordNormalized = vec2(texCoord.x / float(width), texCoord.y / float(height));
		
			vec4 pos3D = vec4(texCoordNormalized, texture(gBufferDepthSampler, texCoordNormalized).r, 1.0);
			pos3D.xyz = pos3D.xyz * 2.0 - 1.0;
			pos3D = invViewProjectionMatrix * pos3D;
			pos3D.xyz /= pos3D.w;

			vec3 normal = normalize(texture(gBufferNormalSampler, texCoordNormalized).xyz * 2.0 - 1.0);
			vec4 material = GGXToBlinnPhong(texture(gBufferMaterialSampler, texCoordNormalized));
			
			uint cacheIndexOffset = INT32_MAX;
			float minWeight = INT32_MAX;
			for(uint k = 0; k < vertexNumber; k++)
			{
				float weight = distance(pos3D.xyz, groupVertexPositions[k]) / max(dot(normal, groupVertexNormals[k]), 0.0);
				if(minWeight > weight)
				{
					minWeight = weight;
					cacheIndexOffset = 8 * k;
				}
			}
			
			//cacheIndexOffset = 0;
			/*
			for(uint k = 0; k < 8 * vertexNumber; k++)
			{
				groupCacheIndices[k] = 150;
			}
			*/
			
			float dmax = 0.0;
			for(uint k = 0; k < 8; k++)
			{
				if(groupCacheIndices[cacheIndexOffset + k] < INT32_MAX)
				{
					vec3 diff = pos3D.xyz - specularCachePositions[groupCacheIndices[cacheIndexOffset + k]].xyz;
					dmax = max(dmax, dot(diff, diff));
				}
			}
			
			vec3 camDir = normalize(eyePos.xyz - pos3D.xyz);
			vec3 reflectCamDir = reflect(-camDir, normal);
			
			dmax = sqrt(max(dmax, 0.0));
			
			vec3 Xpd = vec3(0.0), phiPD = vec3(0.0);
			vec3 Xpg = vec3(0.0), phiPG = vec3(0.0);
			
			float wGesD = 0.0, cacheProxyMinDistanceD = 0.0;
			float wGesG = 0.0, cacheProxyMinDistanceG = 0.0;
			
			for(uint k = 0; k < 8; k++)
			{
				uint cacheIndex = groupCacheIndices[cacheIndexOffset + k];
				if(cacheIndex < INT32_MAX)
				{
					CacheData cache;
					cache.position = specularCachePositions[cacheIndex];
					cache.normal = vec4(normalize(decodeNormal(specularCacheNormalMaterial[cacheIndex].xy)), 0.0);
					
					float dir = max(1.0 - distance(pos3D.xyz, cache.position.xyz) / dmax, 0.01);//without the max the last cache getting always rejected, cause dir == 0.0
						
					float wd = dir * sqrt(max(dot(cache.normal.xyz, normal), 0));
						
					vec3 camCacheDir = normalize(eyePos.xyz - cache.position.xyz);
					float wg = dir * sqrt(max(dot(reflect(-camCacheDir, cache.normal.xyz), reflectCamDir), 0.0));
					
					IndirectLightData indirectLightD;
					indirectLightD.position = proxyLightPosition[2 * cacheIndex];
					indirectLightD.luminousFlux = proxyLightLuminousFlux[2 * cacheIndex];
					
					IndirectLightData indirectLightG;
					indirectLightG.position = proxyLightPosition[2 * cacheIndex + 1];
					indirectLightG.luminousFlux = proxyLightLuminousFlux[2 * cacheIndex + 1];
					
					Xpd += wd * indirectLightD.position.xyz;
					Xpg += wg * indirectLightG.position.xyz;
					
					phiPD += wd * indirectLightD.luminousFlux.xyz;
					phiPG += wg * indirectLightG.luminousFlux.xyz;

					wGesD += wd;
					wGesG += wg;
					
					cacheProxyMinDistanceD += wd * indirectLightD.position.w;
					cacheProxyMinDistanceG += wg * indirectLightG.position.w;
				}
			}
			
			Xpd = wGesD > 0 ? Xpd / wGesD : vec3(0);
			Xpg = wGesG > 0 ? Xpg / wGesG : vec3(0);
			
			phiPD = wGesD > 0 ? phiPD / wGesD : vec3(0);
			phiPG = wGesG > 0 ? phiPG / wGesG : vec3(0);

			cacheProxyMinDistanceD = wGesD > 0 ? cacheProxyMinDistanceD / wGesD : 0;
			cacheProxyMinDistanceG = wGesG > 0 ? cacheProxyMinDistanceG / wGesG : 0;
			
			vec3 lightDirD = Xpd - pos3D.xyz;
			//float lengthD = max(dot(lightDirD, lightDirD), cacheProxyMinDistanceD * cacheProxyMinDistanceD);
			float lengthD = max(length(lightDirD), cacheProxyMinDistanceD);
			lightDirD = normalize(lightDirD);
			float frd = material.x * max(dot(lightDirD, normal), 0.0);
			
			vec3 lightDirG = Xpg - pos3D.xyz;
			//float lengthG = max(dot(lightDirG, lightDirG), dot(cacheProxyMinDistanceG, cacheProxyMinDistanceG));
			float lengthG = max(length(lightDirG), cacheProxyMinDistanceG);
			lightDirG = normalize(lightDirG);
			float frg = material.y * max(dot(lightDirG, normal), 0.0) * pow(max(dot(reflect(-lightDirG, normal), camDir), 0.0), material.w);

			vec4 luminousFlux;
			//luminousFlux = vec4(normal, 1);
			//luminousFlux = vec4(vec3(frd * 0.1), 1);
			//luminousFlux = vec4(0.05 * vec3(lengthG), 1);
			//luminousFlux = vec4(0.1 * Xpg, 1);
			//luminousFlux = vec4(0.001 * phiPD, 1);
			//luminousFlux = vec4(max((frd * phiPD) / (4.0f * PI * lengthD), 0.0), 0.0);
			//luminousFlux = vec4(max((frg * phiPG) / (4.0 * PI * lengthG), 0.0), 1.0);
			luminousFlux = vec4(max((frd * phiPD) / (4.0f * PI * lengthD), 0.0) + max((frg * phiPG) / (4.0 * PI * lengthG), 0.0), 1.0);
			//luminousFlux = vec4(1, 0, 0, 0);
			
			imageStore(indirectLightImage, texCoord, luminousFlux);
		}
		
		memoryBarrierShared();
		barrier();
	}
}