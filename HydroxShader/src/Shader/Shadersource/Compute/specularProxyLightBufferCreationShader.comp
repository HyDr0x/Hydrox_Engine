#version 440 core

#define HALFRESX
#define HALFRESY

#define SAMPLENUMBER
#define SHADOWSAMPLENUMBER
#define SHADOWSAMPLENUMBERROOT
#define WORKGROUPSIZE 128
#define EPSILON 0.00001
#define INT32_MAX 2147483647

#include "../../HydroxShader/include/Shader/Shaderincludes/CacheData.glslh"
#include "../../HydroxShader/include/Shader/Shaderincludes/CameraUBO.glslh"
#include "../../HydroxShader/include/Shader/Shaderincludes/Encodings.glslh"
#include "../../HydroxShader/include/Shader/Shaderincludes/MaterialConversion.glslh"
#include "../../HydroxShader/include/Shader/Shaderincludes/ParaboloidProjection.glslh"

layout(location = 0) uniform sampler2DArray indirectLightPosSampler;
layout(location = 1) uniform sampler2DArray indirectLightNormalAreaSampler;
layout(location = 2) uniform sampler2DArray indirectLightLuminousFluxSampler;
layout(location = 3) uniform sampler2DArray indirectShadowMapSampler;
layout(location = 4) uniform sampler1DArray valQuaternionsSampler;

layout(location = 5) uniform uint reflectiveShadowMapNumber;
layout(location = 6) uniform uint rsmTexRes;
layout(location = 7) uniform uint indirectShadowMapsMinification;
layout(location = 8) uniform uint occluderNumber;
layout(location = 9) uniform uint shadowMapRes;

layout(r32f, binding = 0) readonly uniform image2D edgeCacheOffsetSampler;

layout(std430, binding = 0) buffer specularCachePositionBuffer
{
	vec4 specularCachePositions[];
};

layout(std430, binding = 1) buffer specularCacheNormalMaterialBuffer
{
	vec4 specularCacheNormals[];
};

layout(std430, binding = 2) buffer proxyLightPositionBuffer
{
	vec4 proxyLightPosition[];
};

layout(std430, binding = 3) buffer proxyLightLuminousFluxBuffer
{
	vec4 proxyLightLuminousFlux[];
};

layout(std430, binding = 4) buffer transformedOccluderNormalCoordinatesBuffer
{
	vec4 globalOccluderPosAreaNormal[];
};

vec3 project(in vec3 t, in vec3 b, in vec3 c, in vec3 p)
{
	vec3 diff = normalize(p - c);//normalization to project the point onto the hemisphere
	
	float shareT = dot(diff, t);
	float shareB = dot(diff, b);
	
	return c + t * shareT + b * shareB;
}

float calculateProjectedProxyLightArea(in vec3 cachePos, in vec3 cacheNormal, in vec3 lightDir, in float r)
{
	float cosAngle = max(dot(cacheNormal, normalize(lightDir)), 0.0);
	
	return max((r * r * cosAngle) / (r * r + dot(lightDir, lightDir)), 0.0);
}

float calculateProjectedCacheArea(in vec3 cacheDir, in vec3 cacheNormal0, in vec3 cacheNormal1, in float cacheArea)
{
	float quadCacheDistance = dot(cacheDir, cacheDir);
	cacheDir = normalize(cacheDir);
	
	float cosAngle0 = max(dot(cacheNormal0, cacheDir), 0.0);
	float cosAngle1 = max(dot(cacheNormal1, cacheDir), 0.0);
	
	return max((cacheArea * cosAngle0 * cosAngle1) / (cacheArea + PI * quadCacheDistance), 0.0);
}

float overlappingArea(in vec3 p0, in float length0, in vec3 p1, in float length1, in vec3 t, in vec3 b, inout vec2 areaHeuristicMin, inout vec2 areaHeuristicMax)
{
	vec3 diff = p1 - p0;
	
	float shareT = abs(dot(diff, t));
	float shareB = abs(dot(diff, b));
	
	float minLength = min(length0, length1) * 2.0;//use the full length of the square, not only the half
	float ax = clamp((length0 + length1) - abs(shareT), 0.0, minLength);
	float ay = clamp((length0 + length1) - abs(shareB), 0.0, minLength);
	
	areaHeuristicMin = min(areaHeuristicMin, vec2(shareT - length1, shareB - length1));
	areaHeuristicMax = max(areaHeuristicMax, vec2(shareT + length1, shareB + length1));
	
	return ax * ay;
}

void calculateVisibility(in CacheData cache, in vec3 Xpd, in vec3 Xpg, in vec3 Xpdq, in vec3 Xpgq, out float visibilityD, out float visibilityG)
{
	float areaD = 0.0;
	float areaG = 0.0;
	
	vec3 binormal = normalize(cross(vec3(0.267261241, 0.534522483, 0.801783725), cache.normal.xyz));
	vec3 tangent = normalize(cross(binormal, cache.normal.xyz));
	
	vec3 XpdProj = project(tangent, binormal, cache.position.xyz, Xpd);
	vec3 XpgProj = project(tangent, binormal, cache.position.xyz, Xpg);
	
	vec3 Sd = sqrt(max(Xpdq - (Xpd * Xpd), vec3(EPSILON)));
	vec3 Sg = sqrt(max(Xpgq - (Xpg * Xpg), vec3(EPSILON)));
	
	float Rd = max(Sd.x, max(Sd.y, Sd.z));
	float Rg = max(Sg.x, max(Sg.y, Sg.z));
	
	float Fpd = calculateProjectedProxyLightArea(cache.position.xyz, cache.normal.xyz, Xpd - cache.position.xyz, Rd);
	float Fpg = calculateProjectedProxyLightArea(cache.position.xyz, cache.normal.xyz, Xpg - cache.position.xyz, Rg);
	
	float diffuseSquareSideLength = sqrt(Fpd) * 0.5;
	float specularSquareSideLength = sqrt(Fpg) * 0.5;

	vec2 areaHeuristicMinD = vec2(INT32_MAX), areaHeuristicMaxD = vec2(-INT32_MAX);
	vec2 areaHeuristicMinG = vec2(INT32_MAX), areaHeuristicMaxG = vec2(-INT32_MAX);

	for(int index = 0; index < occluderNumber; index++)
	{
		vec4 occluderPosArea = globalOccluderPosAreaNormal[2 * index];
		vec3 occluderNormal = normalize(globalOccluderPosAreaNormal[2 * index + 1].xyz);
		
		if(dot(normalize(occluderPosArea.xyz - cache.position.xyz), cache.normal.xyz) > 0.01)
		{
			float cacheAABBSideLength = 0.5 * sqrt(calculateProjectedCacheArea(occluderPosArea.xyz - cache.position.xyz, cache.normal.xyz, occluderNormal, occluderPosArea.w));
			
			vec3 cacheProjPos = project(tangent, binormal, cache.position.xyz, occluderPosArea.xyz);
			
			float aD = overlappingArea(XpdProj, diffuseSquareSideLength, cacheProjPos, cacheAABBSideLength, tangent, binormal, areaHeuristicMinD, areaHeuristicMaxD);
			areaD += max(0.0, (aD / Rd) * min(Rd, dot(occluderPosArea.xyz - Xpd, normalize(cache.position.xyz - Xpd))));
			
			float aG = overlappingArea(XpgProj, specularSquareSideLength, cacheProjPos, cacheAABBSideLength, tangent, binormal, areaHeuristicMinG, areaHeuristicMaxG);
			areaG += max(0.0, (aG / Rg) * min(Rg, dot(occluderPosArea.xyz - Xpg, normalize(cache.position.xyz - Xpg))));
		}
	}
	
	areaHeuristicMinD = max(areaHeuristicMinD, vec2(-diffuseSquareSideLength, -diffuseSquareSideLength));
	areaHeuristicMaxD = min(areaHeuristicMaxD, vec2(diffuseSquareSideLength, diffuseSquareSideLength));

	areaHeuristicMinG = max(areaHeuristicMinG, vec2(-specularSquareSideLength, -specularSquareSideLength));
	areaHeuristicMaxG = min(areaHeuristicMaxG, vec2(specularSquareSideLength, specularSquareSideLength));
	
	vec2 diffD = areaHeuristicMaxD - areaHeuristicMinD;
	float proxyLightAreaD = diffD.x * diffD.y;
	areaD = min(areaD, proxyLightAreaD);
	
	vec2 diffG = areaHeuristicMaxG - areaHeuristicMinG;
	float proxyLightAreaG = diffG.x * diffG.y;
	areaG = min(areaG, proxyLightAreaG);
	
	visibilityD = Fpd >= 0.0 ? max(1.0 - areaD / Fpd, 0.0) : 0.0;
	visibilityG = Fpg >= 0.0 ? max(1.0 - areaG / Fpg, 0.0) : 0.0;
}

layout(local_size_x = WORKGROUPSIZE) in;

shared vec4 indirectLightPos[WORKGROUPSIZE];
shared vec4 indirectLightNormalArea[WORKGROUPSIZE];
shared vec4 indirectLightLuminousFlux[WORKGROUPSIZE];

void main()
{
	uint idx = gl_GlobalInvocationID.x;

	const uint cacheNumber = uint(imageLoad(edgeCacheOffsetSampler, ivec2(HALFRESX - 1, HALFRESY - 1)).r);
	
	const uint cachesPerThread = uint(ceil(float(cacheNumber) / float(WORKGROUPSIZE * gl_NumWorkGroups.x)));
	const uint cacheOffset = idx * cachesPerThread;
	const uint cacheEnd = cacheOffset + cachesPerThread;
	
	for(uint i = cacheOffset; i < cacheEnd; i++)
	{
		vec3 Lod = vec3(0.0), Xpd = vec3(0.0), Xpdq = vec3(0.0);
		vec3 Log = vec3(0.0), Xpg = vec3(0.0), Xpgq = vec3(0.0);
		
		float Wgesd = 0.0;
		float Wgesg = 0.0;
		
		CacheData cache;
		vec3 cacheMaterial;
		float frd, frg;
		vec3 camDir;
		
		if(i < cacheNumber)
		{
			vec4 cacheNormalMaterial = specularCacheNormals[i];
			cache.position = specularCachePositions[i];
			cache.normal.xyz = normalize(decodeNormal(cacheNormalMaterial.xy));

			cacheMaterial = GGXToBlinnPhong(vec4(cache.position.w, cacheNormalMaterial.zw, 0)).rga;

			frd = cacheMaterial.x / PI;
			frg = cacheMaterial.y * (cacheMaterial.z + 2.0) / (2.0 * PI);
			
			camDir = normalize(eyePos.xyz - cache.position.xyz);
		}
		
		float visibleIndirectLightNumber = 0.0;
		
		for(uint k = 0; k < reflectiveShadowMapNumber; k++)
		{
			float validLightSamples = 1.0;
			float specularValidSamples = 1.0;
			const uint cacheLoops = uint((SAMPLENUMBER + WORKGROUPSIZE - 1)/ WORKGROUPSIZE);
			
			for(uint j = 0; j < cacheLoops; j++)
			{
				uint sampleIndex = gl_LocalInvocationID.x + j * WORKGROUPSIZE;
				
				if(sampleIndex < SAMPLENUMBER)
				{
					ivec3 texCoords = ivec3(mod(sampleIndex, rsmTexRes), float(sampleIndex / rsmTexRes), k);
					
					indirectLightPos[gl_LocalInvocationID.x] = texelFetch(indirectLightPosSampler, texCoords, 0);
					indirectLightNormalArea[gl_LocalInvocationID.x] = texelFetch(indirectLightNormalAreaSampler, texCoords, 0);
					indirectLightLuminousFlux[gl_LocalInvocationID.x] = texelFetch(indirectLightLuminousFluxSampler, texCoords, 0);
				}
			
				memoryBarrierShared();
				barrier();
			
				if(i < cacheNumber)
				{
					for(uint l = 0; l < WORKGROUPSIZE; l++)
					{
						uint valID = j * WORKGROUPSIZE + l;
						if(valID < SAMPLENUMBER)
						{
							vec4 lightPos = indirectLightPos[l];
							vec4 lightNormalArea = indirectLightNormalArea[l];
							vec3 luminousFlux = indirectLightLuminousFlux[l].rgb;
							
							if(lightPos.w < 1.0) continue;
						
							validLightSamples++;//cancels indirect lightsources which aren't initialized, because there is no geometry behind or lit

							vec3 lightNormal = normalize(lightNormalArea.xyz * 2.0 - 1.0);
							float lightArea = lightNormalArea.w;
							
							vec3 lightDir = lightPos.xyz - cache.position.xyz;
							float quadDistance = dot(lightDir, lightDir);
							lightDir = normalize(lightDir);
							
							float tmpReflectAngle = dot(reflect(-lightDir, cache.normal.xyz), camDir);
							/*
							float solidAngle = lightArea / quadDistance;
							float openingAngle = min(acos(1.0 - solidAngle / (2.0 * PI)), 0.001 * tmpReflectAngle);
							float pixelSolidAngle = min(openingAngle, 0.002);
							*/
							float reflAngle = pow(clamp(tmpReflectAngle, 0.0, 1.0), cacheMaterial.z);

							float F = (max(dot(lightNormal.xyz, normalize(cache.position.xyz - lightPos.xyz)), 0.0) * max(dot(cache.normal.xyz, lightDir), 0.0)) / (lightArea + PI * quadDistance);
							
							float Wd = F;
							float Wg = reflAngle * F;
							
							Xpd += Wd * lightPos.xyz;
							Xpg += Wg * lightPos.xyz;
							
							Xpdq += Wd * lightPos.xyz * lightPos.xyz;
							Xpgq += Wg * lightPos.xyz * lightPos.xyz;
							
							Lod += luminousFlux * frd * F;
							
							float specularLuminance = reflAngle;
							specularValidSamples += step(0.0001, specularLuminance);
							Log += luminousFlux * frg * specularLuminance * F;
							
							Wgesd += Wd;
							Wgesg += Wg;
							
							ivec2 quaternionTexCoord = ivec2(mod(valID, rsmTexRes), valID / rsmTexRes);
							if(mod(quaternionTexCoord.x, indirectShadowMapsMinification) == 0 && mod(quaternionTexCoord.y, indirectShadowMapsMinification) == 0)
							{
								uint ismIndex = quaternionTexCoord.x / indirectShadowMapsMinification + quaternionTexCoord.y * rsmTexRes / (indirectShadowMapsMinification * indirectShadowMapsMinification);
								vec4 q = texelFetch(valQuaternionsSampler, ivec2(ismIndex, k), 0);
								
								float clipDepth;
								vec3 transformedPosition = applyQuaternion(cache.position.xyz - lightPos.xyz, q);
								
								paraboloidProjection(transformedPosition, PARABOLOIDNEAR, PARABOLOIDFAR, transformedPosition, clipDepth);
								
								if(clipDepth > 0.01)
								{
									transformedPosition.xy = (transformedPosition.xy * 0.5 + 0.5) * shadowMapRes;
									transformedPosition.z = transformedPosition.z * 0.5 + 0.5;
									
									transformedPosition.x += mod(ismIndex, SHADOWSAMPLENUMBERROOT) * shadowMapRes;
									transformedPosition.y += (ismIndex / SHADOWSAMPLENUMBERROOT) * shadowMapRes;

									float depth = texelFetch(indirectShadowMapSampler, ivec3(transformedPosition.xy, k), 0).r;

									visibleIndirectLightNumber += clamp(ceil(depth - transformedPosition.z + 0.01), 0, 1);
								}
							}
						}
					}
				}
				
				memoryBarrierShared();
				barrier();
			}

			Lod *= (1.0 / validLightSamples);
			Log *= (1.0 / specularValidSamples);
		}
		
		visibleIndirectLightNumber /= (reflectiveShadowMapNumber * SHADOWSAMPLENUMBER);
		visibleIndirectLightNumber = 1.0;
		
		if(i < cacheNumber)
		{
			Xpd = Wgesd > 0 ? Xpd / Wgesd : vec3(0);
			Xpg = Wgesg > 0 ? Xpg / Wgesg : vec3(0);
			
			Xpdq = Wgesd > 0 ? Xpdq / Wgesd : vec3(0);
			Xpgq = Wgesg > 0 ? Xpgq / Wgesg : vec3(0);
			
			float visibilityD = 1.0, visibilityG = 1.0;
			//calculateVisibility(cache, Xpd, Xpg, Xpdq, Xpgq, visibilityD, visibilityG);
			
			vec3 lightDirD = Xpd - cache.position.xyz;
			float lightAngleD = max(dot(normalize(lightDirD), cache.normal.xyz), 0.0001);

			proxyLightPosition[2 * i] = vec4(Xpd, length(lightDirD));
			proxyLightLuminousFlux[2 * i] = vec4(visibilityD * visibleIndirectLightNumber * (4.0 * PI * Lod * dot(lightDirD, lightDirD)) / max(frd * lightAngleD, 0.0001), 0.0);

			vec3 lightDirG = Xpg - cache.position.xyz;
			float lightQuadDistance = dot(lightDirG, lightDirG);
			lightDirG = normalize(lightDirG);
			float reflAngleG = max(pow(dot(reflect(-lightDirG, cache.normal.xyz), camDir), cacheMaterial.z), 0.0001);
			float lightAngleG = max(dot(lightDirG, cache.normal.xyz), 0.0001);
			
			proxyLightPosition[2 * i + 1] = vec4(Xpg, sqrt(lightQuadDistance));
			proxyLightLuminousFlux[2 * i + 1] = vec4(visibilityG * visibleIndirectLightNumber * (4.0 * PI * Log * lightQuadDistance) / max(frg * reflAngleG * lightAngleG, 0.0001), 0.0);
		}
	}
}