#version 440 core

#define WORKGROUPSIZE 256
#define UINT32_MAX 4294967295

#include "../../HydroxShader/include/Shader/Shaderincludes/CameraUBO.glslh"
#include "../../HydroxShader/include/Shader/Shaderincludes/LightData.glslh"

struct DrawArraysInstancedBaseInstance
{
	uint count;
	uint instanceCount;
	uint baseVertex;
	uint baseInstance;
	uint padding;
};

struct DrawElementsBaseVertexBaseInstanceCommand
{
	uint count;
	uint instanceCount;
	uint firstIndex;
	uint baseVertex;
	uint baseInstance;
};

layout(std430, binding = 0) buffer transformBuffer
{
	mat4 transformMatrices[];
};

layout(std430, binding = 1) buffer boundingBoxBuffer
{
	vec4 bbPoint[];
};

layout(std430, binding = 2) buffer drawCommandBuffer
{
	DrawElementsBaseVertexBaseInstanceCommand drawCommands[];
};

layout(std430, binding = 3) buffer meshIndexBuffer
{
	uint perMeshIndex[];
};

layout(std430, binding = 9) buffer shadowedLightBuffer
{
	ShadowLightData light[];
};

layout(location = 0) uniform uint AABBNumber;

layout(location = 1) uniform int lightIndex;

layout(local_size_x = WORKGROUPSIZE) in;

void main()
{
	uint idx = gl_GlobalInvocationID.x;

	uint bboxesPerThread = max(uint(ceil(AABBNumber / (WORKGROUPSIZE * gl_NumWorkGroups.x))), 1);
	uint bboxOffset = idx * bboxesPerThread;
	
	if(bboxOffset >= AABBNumber)
	{
		return;
	}
	
	uint instanceCount = 0;
	
	mat4 vp = lightIndex == -1 ? viewProjectionMatrix : light[lightIndex].lightViewProj;

	for(unsigned int i = 0; i < bboxesPerThread; i++)
	{
		uint bboxID = bboxOffset + i;
		uint meshIndex = perMeshIndex[bboxID];

		mat4 MVP = vp * transformMatrices[bboxID];

		vec4 plane[6];
		
		plane[0] = vec4(MVP[0][3] + MVP[0][0], MVP[1][3] + MVP[1][0], MVP[2][3] + MVP[2][0], MVP[3][3] + MVP[3][0]);//left plane
		plane[1] = vec4(MVP[0][3] - MVP[0][0], MVP[1][3] - MVP[1][0], MVP[2][3] - MVP[2][0], MVP[3][3] - MVP[3][0]);//right plane

		plane[2] = vec4(MVP[0][3] + MVP[0][1], MVP[1][3] + MVP[1][1], MVP[2][3] + MVP[2][1], MVP[3][3] + MVP[3][1]);//bottom plane
		plane[3] = vec4(MVP[0][3] - MVP[0][1], MVP[1][3] - MVP[1][1], MVP[2][3] - MVP[2][1], MVP[3][3] - MVP[3][1]);//top plane

		plane[4] = vec4(MVP[0][3] + MVP[0][2], MVP[1][3] + MVP[1][2], MVP[2][3] + MVP[2][2], MVP[3][3] + MVP[3][2]);//near plane
		plane[5] = vec4(MVP[0][3] - MVP[0][2], MVP[1][3] - MVP[1][2], MVP[2][3] - MVP[2][2], MVP[3][3] - MVP[3][2]);//far plane

		vec3 newbbMin = bbPoint[2 * meshIndex + 0].xyz;
		vec3 newbbMax = bbPoint[2 * meshIndex + 1].xyz;

		unsigned int inside = 0;
		float d;

		vec3 mulMin, mulMax;
		for(unsigned int j = 0; j < 6; j++)
		{
			mulMin = newbbMin * plane[j].xyz;
			mulMax = newbbMax * plane[j].xyz;
			d = max(mulMin.x, mulMax.x) +
					max(mulMin.y, mulMax.y) +
					max(mulMin.z, mulMax.z) +
					plane[j].w;

			if(d > 0)
			{
				inside++;
			}
		}

		drawCommands[bboxID].instanceCount = uint(inside == 6);
	}
}