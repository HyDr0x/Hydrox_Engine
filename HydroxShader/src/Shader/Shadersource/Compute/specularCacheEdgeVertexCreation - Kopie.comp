#version 440 core

#define THREADTILESIZE 8
#define WORKGROUPSIZE (THREADTILESIZE * THREADTILESIZE)
#define TILESIZE 8
#define TILEMULTI 2
#define TILEPIXELPERTHREAD ((TILESIZE + THREADTILESIZE - 1) / THREADTILESIZE)
#define LIGHTTUBEBINDINGPOINT 0

#define INT32_MAX 2147483647
#define PI 3.14159265359
#define PI_HALF (PI * 0.5)
#define NORMALPHIQ 7
#define NORMALTHETAQ 3
#define DEPTHQ 2

#include "../../HydroxShader/include/Shader/Shaderincludes/CameraUBO.glslh"
#include "../../HydroxShader/include/Shader/Shaderincludes/IndirectLightCollision.glslh"
#include "../../HydroxShader/include/Shader/Shaderincludes/MaterialConversion.glslh"

layout(location = 0) uniform sampler2D gBufferDepthSampler;
layout(location = 1) uniform sampler2D gBufferNormalSampler;
layout(location = 2) uniform sampler2D gBufferMaterialSampler;
layout(location = 3) uniform sampler2D gBufferLinearDepthSampler;

layout(r32f, binding = 0) writeonly uniform image2D vertexOffsetImage;
layout(rgba32f, binding = 1) writeonly uniform image2D vertexPositionImage;
layout(rgba32f, binding = 2) writeonly uniform image2D vertexNormalImage;
layout(r32ui, binding = 3) uniform uimage2D vertexAtomicIndexSampler;

uint depthToBin(in float depth, in uint minDepth, in uint maxDepth)
{
	float ftlMinDepth = uintBitsToFloat(minDepth);
	float ftlMaxDepth = uintBitsToFloat(maxDepth);
	return uint(((depth - ftlMinDepth) / (ftlMaxDepth - ftlMinDepth)) * DEPTHQ);
}

uint normalToBin(in vec3 normal)
{
	uint phiBin = uint(clamp((atan(normal.y, normal.x) + PI) / (2.0 * PI), 0.0, 0.9999) * NORMALPHIQ);
	uint thetaBin = uint(clamp((normal.z * 0.5 + 0.5), 0.0, 0.9999) * NORMALTHETAQ);//[-PI/2,PI/2] --> [0,PI]
	
	return phiBin + NORMALPHIQ * thetaBin;
}

layout(local_size_x = THREADTILESIZE, local_size_y = THREADTILESIZE) in;

shared vec3 groupResultPositions[WORKGROUPSIZE];
shared vec3 groupResultNormals[WORKGROUPSIZE];
shared vec3 groupPosition[WORKGROUPSIZE];
shared vec3 groupNormals[WORKGROUPSIZE];
shared float groupSummedPixelNumber[WORKGROUPSIZE];
shared uint groupNormalBin[NORMALPHIQ * NORMALTHETAQ];//rubics cube normal directions
shared uint groupMinDepth;
shared uint groupMaxDepth;
shared uint groupChoosenDepthBin;
shared uint groupMaxNormalBinID;
shared uint groupMaxNormalBinVotes;
//shared uvec2 groupPerThreadMaxNormalBinVotes[WORKGROUPSIZE];//costs too much shared memory to amortize!

void main()
{
	const uint idx = gl_GlobalInvocationID.x;
	const uint localIDx = gl_LocalInvocationIndex;
	const uvec2 localIDxVec = gl_LocalInvocationID.xy;
	
	const uvec2 tileNumber = (uvec2(width, height) + uvec2(TILESIZE - 1)) / TILESIZE;
	const uint tilesPerGroup = (tileNumber.x * tileNumber.y + gl_NumWorkGroups.x - 1) / gl_NumWorkGroups.x;
	const uint tileStartIndex = gl_WorkGroupID.x * tilesPerGroup;
	const uint tileEndIndex = tileStartIndex + tilesPerGroup;

	const uvec2 tilePixelStartIndex = localIDxVec * TILEPIXELPERTHREAD;

	for(uint i = tileStartIndex; i < tileEndIndex; i++)
	{
		ivec2 blockCoord = ivec2(mod(i, tileNumber.x), i / tileNumber.x);

		if(localIDx == 0)
		{
			groupMinDepth = 0xFFFFFFFF;
			groupMaxDepth = 0;
		}
		
		const uint binsPerThread = (NORMALPHIQ * NORMALTHETAQ + WORKGROUPSIZE - 1) / WORKGROUPSIZE;
		const uint binStartIndex = localIDx * binsPerThread;
		const uint binEndIndex = binStartIndex + binsPerThread;
		for(uint j = binStartIndex; j < binEndIndex; j++)
		{
			if(j < NORMALPHIQ * NORMALTHETAQ)
			{
				groupNormalBin[j] = 0;
			}
		}
		
		memoryBarrierShared();
		barrier();

		uint depthBinCache[TILEPIXELPERTHREAD * TILEPIXELPERTHREAD];
		for(uint j = 0; j < (TILEPIXELPERTHREAD * TILEPIXELPERTHREAD); j++)
		{
			ivec2 texCoord = int(TILESIZE) * blockCoord + ivec2(tilePixelStartIndex) + ivec2(mod(j, TILEPIXELPERTHREAD), j / TILEPIXELPERTHREAD);
			
			float linearDepth = texelFetch(gBufferLinearDepthSampler, texCoord, 0).r;
			if(linearDepth < far)
			{
				atomicMin(groupMinDepth, floatBitsToUint(linearDepth));
				atomicMax(groupMaxDepth, floatBitsToUint(linearDepth));
				
				depthBinCache[j] = floatBitsToUint(linearDepth);
			}
			else
			{
				depthBinCache[j] = INT32_MAX - 1;
			}
		}

		memoryBarrierShared();
		barrier();
		
		
		uint normalBinCache[TILEPIXELPERTHREAD * TILEPIXELPERTHREAD];
		vec3 normalCache[TILEPIXELPERTHREAD * TILEPIXELPERTHREAD];
		
		for(uint j = 0; j < (TILEPIXELPERTHREAD * TILEPIXELPERTHREAD); j++)
		{
			ivec2 texCoord = int(TILESIZE) * blockCoord + ivec2(tilePixelStartIndex) + ivec2(mod(j, TILEPIXELPERTHREAD), j / TILEPIXELPERTHREAD);
			
			vec3 normal = texelFetch(gBufferNormalSampler, texCoord, 0).xyz * 2.0 - 1.0;

			normalCache[j] = normal;
			normalBinCache[j] = normalToBin(normal);
			
			atomicAdd(groupNormalBin[normalBinCache[j]], 1);
			
			depthBinCache[j] = depthToBin(uintBitsToFloat(depthBinCache[j]), groupMinDepth, groupMaxDepth);
		}

		uint vertexNumber = 0;
		
		do
		{
			memoryBarrierShared();
			barrier();
			
			/*//costs too much shard memory to amortize!
			groupPerThreadMaxNormalBinVotes[localIDx] = uvec2(0, INT32_MAX);
			const uint binsPerThread = max(4, (NORMALPHIQ * NORMALTHETAQ + WORKGROUPSIZE - 1) / WORKGROUPSIZE);
			const uint binStartIndex = localIDx * binsPerThread;
			const uint binEndIndex = binStartIndex + binsPerThread;
			for(uint j = binStartIndex; j < binEndIndex; j++)
			{
				if(j < NORMALPHIQ * NORMALTHETAQ && groupNormalBin[j] > groupPerThreadMaxNormalBinVotes[localIDx].x)
				{
					groupPerThreadMaxNormalBinVotes[localIDx] = uvec2(groupNormalBin[j], j);
				}
			}
			
			memoryBarrierShared();
			barrier();
			
			if(localIDx == 0)
			{
				groupMaxNormalBinID = INT32_MAX;
				groupMaxNormalBinVotes = 0;
				groupChoosenDepthBin = INT32_MAX;
				
				for(uint j = 0; j < WORKGROUPSIZE; j++)
				{
					if(groupPerThreadMaxNormalBinVotes[j].x > groupMaxNormalBinVotes)
					{
						groupMaxNormalBinVotes = groupPerThreadMaxNormalBinVotes[j].x;
						groupMaxNormalBinID = groupPerThreadMaxNormalBinVotes[j].y;
					}
				}
			}
		*/
			if(localIDx == 0)
			{
				groupMaxNormalBinID = INT32_MAX;
				groupMaxNormalBinVotes = 0;
				groupChoosenDepthBin = INT32_MAX;
				
				for(uint j = 0; j < (NORMALPHIQ * NORMALTHETAQ); j++)
				{
					if(groupNormalBin[j] > groupMaxNormalBinVotes)
					{
						groupMaxNormalBinVotes = groupNormalBin[j];
						groupMaxNormalBinID = j;
					}
				}
			}

			memoryBarrierShared();
			barrier();
		
			if(groupMaxNormalBinVotes > 0 /*&& groupMaxNormalBinVotes < (TILESIZE * TILESIZE)*/)
			{
				float summedPixels = 0.0;
				vec3 summedPosition = vec3(0.0);
				vec3 summedNormals = vec3(0.0);
				for(uint j = 0; j < (TILEPIXELPERTHREAD * TILEPIXELPERTHREAD); j++)
				{
					ivec2 texCoord = int(TILESIZE) * blockCoord + ivec2(tilePixelStartIndex) + ivec2(mod(j, TILEPIXELPERTHREAD), j / TILEPIXELPERTHREAD);
					vec2 texCoordNormalized = texCoord / vec2(width, height);
					
					if(normalBinCache[j] == groupMaxNormalBinID)
					{
						if(groupChoosenDepthBin == INT32_MAX && depthBinCache[j] != INT32_MAX - 1)
						{
							atomicCompSwap(groupChoosenDepthBin, INT32_MAX, depthBinCache[j]);
						}
						
						if(depthBinCache[j] == groupChoosenDepthBin)
						{
							float depth = texelFetch(gBufferDepthSampler, texCoord, 0).r;
							
							if(depth < 0.9999)
							{
								vec4 position3D = invViewProjectionMatrix * (vec4(texCoordNormalized, depth, 1.0) * 2.0 - 1.0);
								position3D /= position3D.w;
								
								summedPosition += position3D.xyz;
								summedNormals += normalCache[j];

								summedPixels++;
							}
							
							depthBinCache[j] = INT32_MAX - 1;
							atomicAdd(groupNormalBin[groupMaxNormalBinID], -1);
						}
					}
				}
				
				groupPosition[localIDx] = summedPosition;
				groupNormals[localIDx] = summedNormals;
				groupSummedPixelNumber[localIDx] = summedPixels;

				memoryBarrierShared();
				barrier();
				
				
				float resultPixelCounter = 0.0;
				vec3 resultPosition = vec3(0.0);
				vec3 resultNormals = vec3(0.0);
				
				for(uint j = 0; j < THREADTILESIZE; j++)//parallel scan should be more efficient here
				{
					uint index = localIDx * THREADTILESIZE + j;
					if(index < THREADTILESIZE * THREADTILESIZE && groupSummedPixelNumber[index] > 0)
					{
						resultPixelCounter += groupSummedPixelNumber[index];
						resultPosition += groupPosition[index];
						resultNormals += groupNormals[index];
					}
				}
				
				memoryBarrierShared();
				barrier();
				
				groupSummedPixelNumber[localIDx] = resultPixelCounter;
				groupPosition[localIDx] = resultPosition;
				groupNormals[localIDx] = resultNormals;
				
				memoryBarrierShared();
				barrier();
				
				if(localIDx == 0)
				{
					resultPixelCounter = 0.0;
					resultPosition = vec3(0.0);
					resultNormals = vec3(0.0);
				
					for(uint j = 0; j < THREADTILESIZE; j++)//parallel scan should be more efficient here
					{
						if(groupSummedPixelNumber[j] > 0)
						{
							resultPixelCounter += groupSummedPixelNumber[j];
							resultPosition += groupPosition[j];
							resultNormals += groupNormals[j];
						}
					}

					if(resultPixelCounter > 0)
					{
						resultPosition /= resultPixelCounter;
						resultNormals = normalize(resultNormals / resultPixelCounter);

						groupResultPositions[vertexNumber] = resultPosition;
						groupResultNormals[vertexNumber] = resultNormals;

						vertexNumber++;
					}
				}
			}
			else if(localIDx == 0)
			{
				groupNormalBin[groupMaxNormalBinID] = 0;
			}
		} while(groupMaxNormalBinVotes > 0);
		
		if(localIDx == 0)
		{
			ivec2 indexBlockCoord = blockCoord / TILEMULTI;
			uint vertexOffset = imageAtomicAdd(vertexAtomicIndexSampler, indexBlockCoord, vertexNumber);
			
			for(uint j = 0; j < vertexNumber; j++)
			{
				ivec2 texCoord = int(TILEMULTI * TILESIZE) * indexBlockCoord + ivec2(mod(vertexOffset + j, TILEMULTI * TILESIZE), (vertexOffset + j) / (TILEMULTI * TILESIZE));
				imageStore(vertexOffsetImage, texCoord, vec4(1.0));
				imageStore(vertexPositionImage, texCoord, vec4(groupResultPositions[j], 0.0));
				imageStore(vertexNormalImage, texCoord, vec4(groupResultNormals[j], 0.0));
			}
		}
		
		memoryBarrierShared();
		barrier();
	}
}