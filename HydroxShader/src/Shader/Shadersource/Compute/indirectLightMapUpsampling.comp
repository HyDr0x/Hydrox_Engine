#version 440 core

#define WORKGROUPTILESIZE 64
#define RESOLUTIONDIVISOR
#define UPSAMPLINGRANGE 3
#define UPSAMPLINGMULT (UPSAMPLINGRANGE * UPSAMPLINGRANGE)

#include "../../HydroxShader/include/Shader/Shaderincludes/CameraUBO.glslh"

layout(location = 0) uniform ivec2 originalResolution;
layout(location = 1) uniform ivec2 upsampledResolution;

layout(location = 3) uniform sampler2D readDownSampledGBufferLinearDepthMap;
layout(location = 4) uniform sampler2D readDownSampledGBufferNormalMap;
layout(location = 5) uniform sampler2D readDownSampledIndirectLightMap;
layout(location = 6) uniform sampler2D readUpSampledGBufferLinearDepthMap;
layout(location = 7) uniform sampler2D readUpSampledGBufferNormalMap;

layout(rgba16f, binding = 0) writeonly uniform image2D writeIndirectLightMap;

layout(local_size_x = WORKGROUPTILESIZE) in;

void main()
{
	const uint idx = gl_GlobalInvocationID.x;
	const uint localID = gl_LocalInvocationIndex;
	
	const uint threadNumber = WORKGROUPTILESIZE * gl_NumWorkGroups.x;
	
	const uint pixelsPerThread = (upsampledResolution.x * upsampledResolution.y + threadNumber - 1) / threadNumber;
	const uint pixelStartIndex = idx * pixelsPerThread;
	const uint pixelEndIndex = pixelStartIndex + pixelsPerThread;

	for(uint i = pixelStartIndex; i < pixelEndIndex; i++)
	{
		ivec2 texCoord = ivec2(mod(i, upsampledResolution.x), i / upsampledResolution.x);
		ivec2 lowResOrigTexCoord = texCoord / RESOLUTIONDIVISOR;
		
		vec4 indirectLight = vec4(0.0);
		vec3 referenceNormal;
		float referenceDepth;
		
		referenceDepth = texelFetch(readUpSampledGBufferLinearDepthMap, texCoord, 0).r;
		referenceNormal = texelFetch(readUpSampledGBufferNormalMap, texCoord, 0).xyz * 2.0 - 1.0;

		float wGes = 0.0;
		for(uint j = 0; j < UPSAMPLINGMULT; j++)
		{
			ivec2 lowResTexCoord = lowResOrigTexCoord + ivec2(mod(j, UPSAMPLINGRANGE), j / UPSAMPLINGRANGE) - ivec2(UPSAMPLINGRANGE / 2);

			if(0 <= lowResTexCoord.x && lowResTexCoord.x < originalResolution.x &&
				 0 <= lowResTexCoord.y && lowResTexCoord.y < originalResolution.y)
			{
				float depth = texelFetch(readDownSampledGBufferLinearDepthMap, lowResTexCoord, 0).r;
				vec3 normal = texelFetch(readDownSampledGBufferNormalMap, lowResTexCoord, 0).xyz * 2.0 - 1.0;
			
				uvec2 distance = abs(texCoord - (lowResTexCoord * RESOLUTIONDIVISOR));
				uint blockDistance = max(distance.x, distance.y);
				
				float weight = (1.0 / float(UPSAMPLINGMULT)) * (1.0 - float(blockDistance) / float(2 * RESOLUTIONDIVISOR - 1)) * max(dot(referenceNormal, normal), 0.0) * (1.0 - min(abs(depth - referenceDepth) / far, 1.0));
				
				indirectLight += weight * texelFetch(readDownSampledIndirectLightMap, lowResTexCoord, 0);
				
				wGes += weight;
			}
		}

		indirectLight /= wGes;
		
		imageStore(writeIndirectLightMap, texCoord, vec4(indirectLight));
	}
}