#version 440 core

#define WORKGROUPSIZE 256
#define INT32_MAX 2147483647

#include "../../HydroxShader/include/Shader/Shaderincludes/CameraUBO.glslh"

layout(r32f, binding = 0) readonly uniform image2D vertexOffsets;
layout(r32f, binding = 1) readonly uniform image2D edgeCacheOffsets;

layout(std430, binding = 0) buffer vertexPositionBuffer
{
	vec4 vertexPositions[];
};

layout(std430, binding = 1) buffer vertexNormalBuffer
{
	vec4 vertexNormals[];
};

layout(std430, binding = 2) buffer specularCachePositionBuffer
{
	vec4 specularCachePositions[];
};

layout(std430, binding = 3) buffer specularCacheNormalMaterialBuffer
{
	vec4 specularCacheNormalMaterials[];
};

layout(std430, binding = 4) buffer specularCacheIndices0Buffer
{
	vec4 specularCacheIndices0[];
};

layout(std430, binding = 5) buffer specularCacheIndices1Buffer
{
	vec4 specularCacheIndices1[];
};

layout(location = 0) uniform uint borderVertexNumber;

layout(local_size_x = WORKGROUPSIZE) in;

shared vec3 cachePositions[WORKGROUPSIZE];
shared vec3 cacheNormals[WORKGROUPSIZE];

void main()
{
	const uint idx = gl_GlobalInvocationID.x;
	
	const uint cacheNumber = uint(imageLoad(edgeCacheOffsets, ivec2(width - 1, height - 1)).r);

	const uint threadNumber = WORKGROUPSIZE * gl_NumWorkGroups.x;
	
	const uint vertexNumber = uint(imageLoad(vertexOffsets, ivec2(width - 1, height - 1)).r);
	const uint verticesPerThread = uint(float(vertexNumber + threadNumber - 1) / float(threadNumber));
	const uint vertexOffset = borderVertexNumber + idx * verticesPerThread;
	const uint vertexEnd = vertexOffset + verticesPerThread;
	
	for(uint i = vertexOffset; i < vertexEnd; i++)
	{
		vec3 vertexPosition = vertexPositions[i].xyz;
		vec3 vertexNormal = normalize(vertexNormals[i].xyz);
		
		uint indices[8] = uint[](INT32_MAX, INT32_MAX, INT32_MAX, INT32_MAX, INT32_MAX, INT32_MAX, INT32_MAX, INT32_MAX);
		float weights[8] = float[](INT32_MAX, INT32_MAX, INT32_MAX, INT32_MAX, INT32_MAX, INT32_MAX, INT32_MAX, INT32_MAX);
		/*
		for(uint j = 0; j < 8; j++)
		{
			indices[j] = j;
		}*/
		
		vec4 projPos = viewProjectionMatrix * vec4(vertexPosition, 1.0);
		projPos /= projPos.w;
		vec2 projVertexPos = vec2(projPos.xy * 0.5 + 0.5) * vec2(width, height);
		
		uint maximumIndex = 0;

		uint cacheLoopEnd = WORKGROUPSIZE * uint((cacheNumber + WORKGROUPSIZE - 1) / float(WORKGROUPSIZE));
		for(uint j = 0; j < cacheLoopEnd; j += WORKGROUPSIZE)
		{
			if(j + gl_LocalInvocationID.x < cacheNumber)
			{
				cachePositions[gl_LocalInvocationID.x] = specularCachePositions[j + gl_LocalInvocationID.x].xyz;
				cacheNormals[gl_LocalInvocationID.x] = normalize(specularCacheNormalMaterials[j + gl_LocalInvocationID.x].xyz);
			}
			
			memoryBarrierShared();
			barrier();
			
			if(i < vertexNumber + borderVertexNumber)
			{
				for(uint l = 0; l < WORKGROUPSIZE; l++)
				{
					if(j + l < cacheNumber)
					{
						vec4 tmpProjPos = viewProjectionMatrix * vec4(cachePositions[l], 1.0);
						tmpProjPos /= tmpProjPos.w;
						vec2 projCachePos = vec2(tmpProjPos.xy * 0.5 + 0.5) * vec2(width, height);
					
						if(distance(projCachePos, projVertexPos) < 16.0)
						{
							vec3 cachePosDistance = cachePositions[l] - vertexPosition;
							float angle = dot(vertexNormal, cacheNormals[l]);
							float weight = max(length(cachePosDistance), 0.0) / max(pow(angle, 1.0), 0.00001);

							if(weight < weights[maximumIndex])
							{
								indices[maximumIndex] = j + l;
								weights[maximumIndex] = weight;
								
								maximumIndex = 7;
								for(int k = 0; k < 7; k++)
								{
									//int compareVal = int(sign(int(weights[k] - weights[maximumIndex])));
									//maximumIndex = ((compareVal + 1) / 2) * k + ((-compareVal + 1) / 2) * maximumIndex;
									
									if(weights[maximumIndex] < weights[k])
									{
										maximumIndex = k;
									}
								}
							}
						}
					}
				}
			}
			
			memoryBarrierShared();
			barrier();
		}

		specularCacheIndices0[i] = vec4(indices[0], indices[1], indices[2], indices[3]);
		specularCacheIndices1[i] = vec4(indices[4], indices[5], indices[6], indices[7]);
	}
}