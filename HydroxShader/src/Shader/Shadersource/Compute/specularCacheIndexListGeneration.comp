#version 440 core

#define WORKGROUPSIZE 64
#define CACHETILESIZE 32
#define VERTEXTILESIZE 16
#define INT32_MAX 2147483647
#define CACHEROUNDS 2

#include "../../HydroxShader/include/Shader/Shaderincludes/CameraUBO.glslh"
#include "../../HydroxShader/include/Shader/Shaderincludes/Encodings.glslh"

layout(r32f, binding = 0) readonly uniform image2D cacheOffsetImage;
layout(rgba32f, binding = 1) readonly uniform image2D cachePositionImage;
layout(rgba32f, binding = 2) readonly uniform image2D cacheNormalImage;
layout(r32ui, binding = 3) readonly uniform uimage2D cacheNumberPerTileImage;

layout(r32f, binding = 4) readonly uniform image2D vertexOffsetImage;
layout(rgba32f, binding = 5) readonly uniform image2D vertexPositionImage;
layout(rgba32f, binding = 6) readonly uniform image2D vertexNormalImage;
layout(r32ui, binding = 7) readonly uniform uimage2D vertexNumberPerTileImage;

layout(std430, binding = 0) buffer vertexPositionBuffer
{
	vec4 vertexPositions[];
};

layout(std430, binding = 1) buffer vertexNormalBuffer
{
	vec4 vertexNormals[];
};

layout(std430, binding = 2) buffer specularCachePositionBuffer
{
	vec4 specularCachePositions[];
};

layout(std430, binding = 3) buffer specularCacheNormalMaterialBuffer
{
	vec4 specularCacheNormals[];
};

layout(std430, binding = 4) buffer specularCacheIndices0Buffer
{
	vec4 specularCacheIndices0[];
};

layout(std430, binding = 5) buffer specularCacheIndices1Buffer
{
	vec4 specularCacheIndices1[];
};

layout(location = 0) uniform uint borderVertexNumber;

layout(local_size_x = WORKGROUPSIZE) in;

shared vec3 groupCachePositions[WORKGROUPSIZE];
shared vec3 groupCacheNormals[WORKGROUPSIZE];
shared uint groupCacheIndex[WORKGROUPSIZE];
shared uint groupCacheNumberPerTile[(CACHEROUNDS - 1) * 8 + 1];
shared uint groupCacheNumber;

void main()
{
	const uint idx = gl_GlobalInvocationID.x;
	const uint localIDx = gl_LocalInvocationIndex;
	
	const uvec2 cacheTileNumber = (uvec2(width, height) + uvec2(CACHETILESIZE - 1)) / CACHETILESIZE;
	const uint cacheTilesPerGroup = (cacheTileNumber.x * cacheTileNumber.y + gl_NumWorkGroups.x - 1) / gl_NumWorkGroups.x;
	const uint cacheTileStartIndex = gl_WorkGroupID.x * cacheTilesPerGroup;
	const uint cacheTileEndIndex = cacheTileStartIndex + cacheTilesPerGroup;
	
	const uvec2 vertexTileNumber = (uvec2(width, height) + uvec2(VERTEXTILESIZE - 1)) / VERTEXTILESIZE;
	const uint vertexTilesPerGroup = (vertexTileNumber.x * vertexTileNumber.y + gl_NumWorkGroups.x - 1) / gl_NumWorkGroups.x;
	const uint vertexTileStartIndex = gl_WorkGroupID.x * vertexTilesPerGroup;
	const uint vertexTileEndIndex = vertexTileStartIndex + vertexTilesPerGroup;

	for(uint i = vertexTileStartIndex; i < vertexTileEndIndex; i++)
	{
		ivec2 vertexBlockCoord = ivec2(mod(i, vertexTileNumber.x), i / vertexTileNumber.x);
		ivec2 cacheBlockCoord = (vertexBlockCoord * VERTEXTILESIZE) / ivec2(CACHETILESIZE);
		
		const uint vertexNumber = imageLoad(vertexNumberPerTileImage, vertexBlockCoord).r;
		const uint verticesPerThread = (vertexNumber + WORKGROUPSIZE - 1) / WORKGROUPSIZE;
		const uint vertexStartIndex = verticesPerThread * localIDx;
		const uint vertexEndIndex = vertexStartIndex + verticesPerThread;
		
		for(uint j = vertexStartIndex; j < vertexEndIndex; j++)
		{
			ivec2 texCoord = vertexBlockCoord * VERTEXTILESIZE + ivec2(mod(j, VERTEXTILESIZE), j / VERTEXTILESIZE);

			vec3 vertexPosition;
			vec3 vertexNormal;
			
			if(texCoord.x < width && texCoord.y < height)
			{
				vertexPosition = imageLoad(vertexPositionImage, texCoord).xyz;
				vertexNormal = normalize(imageLoad(vertexNormalImage, texCoord).xyz);
			}
			
			uint indices[8] = uint[](INT32_MAX, INT32_MAX, INT32_MAX, INT32_MAX, INT32_MAX, INT32_MAX, INT32_MAX, INT32_MAX);
			float weights[8] = float[](INT32_MAX, INT32_MAX, INT32_MAX, INT32_MAX, INT32_MAX, INT32_MAX, INT32_MAX, INT32_MAX);
			
			uint maximumIndex = 0;
			
			for(uint k = 0; k < CACHEROUNDS; k++)
			{
				const uint cacheBlockNumber = max(k * 8, 1);
				const uint sideLength = 2 * k;
				
				const uint blocksPerThread = (cacheBlockNumber + WORKGROUPSIZE - 1) / WORKGROUPSIZE;
				const uint startBlockIndex = localIDx * blocksPerThread;
				const uint endBlockIndex = startBlockIndex + blocksPerThread;
				
				for(uint l = startBlockIndex; l < endBlockIndex; l++)
				{
					if(l < cacheBlockNumber)
					{
						ivec2 cacheNumberTexCoord = cacheBlockCoord;
						if(k > 0)
						{
							if(l < k * 4)//smaller than cacheBlockNumber / 2
							{
								cacheNumberTexCoord += (ivec2(min(l, sideLength), max(int(l) - int(sideLength), 0)) - ivec2(k));
							}
							else
							{
								cacheNumberTexCoord += (ivec2(max(int(cacheBlockNumber) - int(sideLength) - int(l), 0), min(cacheBlockNumber - l, sideLength)) - ivec2(k));
							}
						}
						
						uint blockCacheNumber = 0;
					
						if(0 <= cacheNumberTexCoord.x && cacheNumberTexCoord.x < cacheTileNumber.x &&
							 0 <= cacheNumberTexCoord.y && cacheNumberTexCoord.y < cacheTileNumber.y)
						{
							blockCacheNumber = imageLoad(cacheNumberPerTileImage, cacheNumberTexCoord).r;
						}
					
						groupCacheNumberPerTile[l] = blockCacheNumber;
					}
				}

				memoryBarrierShared();
				barrier();

				if(localIDx == 0)
				{
					uint tmpCacheNumber = 0;
					for(uint l = 0; l < cacheBlockNumber; l++)
					{
						tmpCacheNumber += groupCacheNumberPerTile[l];
					}
					
					groupCacheNumber = tmpCacheNumber;
				}
				
				memoryBarrierShared();
				barrier();
				
				const uint cacheLoopNumber = WORKGROUPSIZE * ((groupCacheNumber + WORKGROUPSIZE - 1) / WORKGROUPSIZE);
				for(uint l = 0; l < cacheLoopNumber; l += WORKGROUPSIZE)
				{
					const uint cacheIndex = l + localIDx;

					if(cacheIndex < groupCacheNumber)
					{
						uint cacheBlockIndex;
						uint roundCacheStartIndex = 0;
						for(uint m = 0; m < cacheBlockNumber; m++)
						{
							roundCacheStartIndex += groupCacheNumberPerTile[m];
							if(roundCacheStartIndex > cacheIndex)
							{
								cacheBlockIndex = m;
								break;
							}
						}

						ivec2 cacheNumberTexCoord = cacheBlockCoord;
						if(k > 0)
						{
							if(cacheBlockIndex < k * 4)//smaller than cacheBlockNumber / 2
							{
								cacheNumberTexCoord += (ivec2(min(cacheBlockIndex, sideLength), max(int(cacheBlockIndex) - int(sideLength), 0)) - ivec2(k));
							}
							else
							{
								cacheNumberTexCoord += (ivec2(max(int(cacheBlockNumber) - int(sideLength) - int(cacheBlockIndex), 0), min(cacheBlockNumber - cacheBlockIndex, sideLength)) - ivec2(k));
							}
						}
						
						uint innerBlockCacheIndex = cacheIndex - (roundCacheStartIndex - groupCacheNumberPerTile[cacheBlockIndex]);
						ivec2 innerCacheBlockCoord = cacheNumberTexCoord * CACHETILESIZE + ivec2(mod(innerBlockCacheIndex, CACHETILESIZE), innerBlockCacheIndex / CACHETILESIZE);

						if(0 <= innerCacheBlockCoord.x && innerCacheBlockCoord.x < width &&
							 0 <= innerCacheBlockCoord.y && innerCacheBlockCoord.y < height)
						{
							groupCachePositions[localIDx] = imageLoad(cachePositionImage, innerCacheBlockCoord).xyz;
							groupCacheNormals[localIDx] = normalize(decodeNormal(imageLoad(cacheNormalImage, innerCacheBlockCoord).xy));
							groupCacheIndex[localIDx] = uint(imageLoad(cacheOffsetImage, innerCacheBlockCoord).r - 1);
						}
					}

					memoryBarrierShared();
					barrier();
					
					if(j < vertexNumber )
					{
						for(uint m = 0; m < WORKGROUPSIZE; m++)
						{
							if(l + m < max(int(groupCacheNumber) - 0, 0))
							{
								vec3 cachePosDistance = groupCachePositions[m] - vertexPosition;
								float angle = dot(vertexNormal, groupCacheNormals[m]);
								float weight = max(length(cachePosDistance), 0.0) / max(pow(angle, 1.0), 0.00001);

								if(weight < weights[maximumIndex])
								{
									indices[maximumIndex] = groupCacheIndex[m];
									weights[maximumIndex] = weight;
									
									maximumIndex = 7;
									for(int n = 0; n < 7; n++)
									{
										//int compareVal = int(sign(int(weights[n] - weights[maximumIndex])));
										//maximumIndex = ((compareVal + 1) / 2) * n + ((-compareVal + 1) / 2) * maximumIndex;
										
										if(weights[maximumIndex] < weights[n])
										{
											maximumIndex = n;
										}
									}
								}
							}
						}
					}

					memoryBarrierShared();
					barrier();
				}
			}
		
			if(j < vertexNumber && texCoord.x < width && texCoord.y < height)
			{		
				const uint vertexOffset = borderVertexNumber + uint(imageLoad(vertexOffsetImage, texCoord).r - 1);
				specularCacheIndices0[vertexOffset] = vec4(indices[0], indices[1], indices[2], indices[3]);
				specularCacheIndices1[vertexOffset] = vec4(indices[4], indices[5], indices[6], indices[7]);
			}
		}
	}
}