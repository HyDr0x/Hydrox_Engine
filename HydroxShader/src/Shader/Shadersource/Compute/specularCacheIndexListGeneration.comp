#version 440 core

#define HALFRESX
#define HALFRESY
#define CACHEROUNDS

#define GIINDEXWORKGROUPSIZE
#define CACHETILESIZE
#define VERTEXTILEMULTI
#define VERTEXTILESIZE
#define MULTVERTEXTILESIZE (VERTEXTILEMULTI * VERTEXTILESIZE)
#define INT32_MAX 2147483647

#include "../../HydroxShader/include/Shader/Shaderincludes/CameraUBO.glslh"
#include "../../HydroxShader/include/Shader/Shaderincludes/Encodings.glslh"

layout(r32f, binding = 0) readonly uniform image2D cacheOffsetImage;
layout(rgba32f, binding = 1) readonly uniform image2D cachePositionImage;
layout(rgba32f, binding = 2) readonly uniform image2D cacheNormalImage;
layout(r32ui, binding = 3) readonly uniform uimage2D cacheNumberPerTileImage;

layout(rgba32f, binding = 4) readonly uniform image2D vertexPositionImage;
layout(rgba32f, binding = 5) readonly uniform image2D vertexNormalImage;
layout(r32ui, binding = 6) readonly uniform uimage2D vertexNumberPerTileImage;

layout(std430, binding = 0) buffer specularCacheIndicesBuffer
{
	uint specularCacheIndices[];
};

layout(location = 0) uniform uint borderVertexNumber;

layout(local_size_x = GIINDEXWORKGROUPSIZE) in;

shared vec3 groupCachePositions[GIINDEXWORKGROUPSIZE];
shared vec3 groupCacheNormals[GIINDEXWORKGROUPSIZE];
shared uint groupCacheIndex[GIINDEXWORKGROUPSIZE];
shared uint groupCacheNumberPerTile[(CACHEROUNDS - 1) * 8 + 1];
shared uint groupCacheNumber;

void main()
{
	const uint idx = gl_GlobalInvocationID.x;
	const uint localIDx = gl_LocalInvocationIndex;
		
	const uvec2 vertexTileNumber = (uvec2(HALFRESX, HALFRESY) + uvec2(MULTVERTEXTILESIZE - 1)) / MULTVERTEXTILESIZE;
	const ivec2 vertexTilePixelNumber = ivec2(vertexTileNumber) * MULTVERTEXTILESIZE;
	const uint vertexTilesPerGroup = (vertexTileNumber.x * vertexTileNumber.y + gl_NumWorkGroups.x - 1) / gl_NumWorkGroups.x;
	const uint vertexTileStartIndex = gl_WorkGroupID.x * vertexTilesPerGroup;
	const uint vertexTileEndIndex = vertexTileStartIndex + vertexTilesPerGroup;

	for(uint i = vertexTileStartIndex; i < vertexTileEndIndex; i++)
	{
		ivec2 vertexBlockCoord = ivec2(mod(i, vertexTileNumber.x), i / vertexTileNumber.x);
		
		ivec2 cacheBlockCoord = (vertexBlockCoord * MULTVERTEXTILESIZE) / ivec2(CACHETILESIZE);
		
		const uint vertexNumber = imageLoad(vertexNumberPerTileImage, vertexBlockCoord).r;
		const uint verticesPerThread = (vertexNumber + GIINDEXWORKGROUPSIZE - 1) / GIINDEXWORKGROUPSIZE;
		const uint vertexStartIndex = verticesPerThread * localIDx;
		const uint vertexEndIndex = vertexStartIndex + verticesPerThread;
		
		for(uint j = vertexStartIndex; j < vertexEndIndex; j++)
		{
			ivec2 texCoord = vertexBlockCoord * MULTVERTEXTILESIZE + ivec2(mod(j, MULTVERTEXTILESIZE), j / MULTVERTEXTILESIZE);

			vec3 vertexPosition;
			vec3 vertexNormal;
			
			if(texCoord.x < vertexTilePixelNumber.x && texCoord.y < vertexTilePixelNumber.y)
			{
				vertexPosition = imageLoad(vertexPositionImage, texCoord).xyz;
				vertexNormal = normalize(imageLoad(vertexNormalImage, texCoord).xyz);
			}
			
			uint indices[8] = uint[](INT32_MAX, INT32_MAX, INT32_MAX, INT32_MAX, INT32_MAX, INT32_MAX, INT32_MAX, INT32_MAX);
			float weights[8] = float[](INT32_MAX, INT32_MAX, INT32_MAX, INT32_MAX, INT32_MAX, INT32_MAX, INT32_MAX, INT32_MAX);
			
			uint maximumIndex = 0;
			
			for(uint k = 0; k < CACHEROUNDS; k++)
			{
				const uint cacheBlockNumber = max(k * 8, 1);
				const uint sideLength = 2 * k;
				
				const uint blocksPerThread = (cacheBlockNumber + GIINDEXWORKGROUPSIZE - 1) / GIINDEXWORKGROUPSIZE;
				const uint startBlockIndex = localIDx * blocksPerThread;
				const uint endBlockIndex = startBlockIndex + blocksPerThread;
				
				for(uint l = startBlockIndex; l < endBlockIndex; l++)
				{
					if(l < cacheBlockNumber)
					{
						ivec2 cacheNumberTexCoord = cacheBlockCoord;
						if(k > 0)
						{
							if(l < k * 4)//smaller than cacheBlockNumber / 2
							{
								cacheNumberTexCoord += (ivec2(min(l, sideLength), max(int(l) - int(sideLength), 0)) - ivec2(k));
							}
							else
							{
								cacheNumberTexCoord += (ivec2(max(int(cacheBlockNumber) - int(sideLength) - int(l), 0), min(cacheBlockNumber - l, sideLength)) - ivec2(k));
							}
						}
						
						uint blockCacheNumber = 0;
					
						//if(0 <= cacheNumberTexCoord.x && cacheNumberTexCoord.x < cacheTileNumber.x &&
						//	 0 <= cacheNumberTexCoord.y && cacheNumberTexCoord.y < cacheTileNumber.y)
						{
							blockCacheNumber = imageLoad(cacheNumberPerTileImage, cacheNumberTexCoord).r;
						}
					
						groupCacheNumberPerTile[l] = blockCacheNumber;
					}
				}

				memoryBarrierShared();
				barrier();

				if(localIDx == 0)
				{
					uint tmpCacheNumber = 0;
					for(uint l = 0; l < cacheBlockNumber; l++)
					{
						tmpCacheNumber += groupCacheNumberPerTile[l];
					}
					
					groupCacheNumber = tmpCacheNumber;
				}
				
				memoryBarrierShared();
				barrier();
				
				const uint cacheLoopNumber = GIINDEXWORKGROUPSIZE * ((groupCacheNumber + GIINDEXWORKGROUPSIZE - 1) / GIINDEXWORKGROUPSIZE);
				for(uint l = 0; l < cacheLoopNumber; l += GIINDEXWORKGROUPSIZE)
				{
					const uint cacheIndex = l + localIDx;

					if(cacheIndex < groupCacheNumber)
					{
						uint cacheBlockIndex;
						uint roundCacheStartIndex = 0;
						for(uint m = 0; m < cacheBlockNumber; m++)
						{
							roundCacheStartIndex += groupCacheNumberPerTile[m];
							if(roundCacheStartIndex > cacheIndex)
							{
								cacheBlockIndex = m;
								break;
							}
						}

						ivec2 cacheNumberTexCoord = cacheBlockCoord;
						if(k > 0)
						{
							if(cacheBlockIndex < k * 4)//smaller than cacheBlockNumber / 2
							{
								cacheNumberTexCoord += (ivec2(min(cacheBlockIndex, sideLength), max(int(cacheBlockIndex) - int(sideLength), 0)) - ivec2(k));
							}
							else
							{
								cacheNumberTexCoord += (ivec2(max(int(cacheBlockNumber) - int(sideLength) - int(cacheBlockIndex), 0), min(cacheBlockNumber - cacheBlockIndex, sideLength)) - ivec2(k));
							}
						}
						
						uint innerBlockCacheIndex = cacheIndex - (roundCacheStartIndex - groupCacheNumberPerTile[cacheBlockIndex]);
						ivec2 innerCacheBlockCoord = cacheNumberTexCoord * CACHETILESIZE + ivec2(mod(innerBlockCacheIndex, CACHETILESIZE), innerBlockCacheIndex / CACHETILESIZE);

						//if(0 <= innerCacheBlockCoord.x && innerCacheBlockCoord.x < HALFRESX &&
						//	 0 <= innerCacheBlockCoord.y && innerCacheBlockCoord.y < HALFRESY)
						{
							groupCachePositions[localIDx] = imageLoad(cachePositionImage, innerCacheBlockCoord).xyz;
							groupCacheNormals[localIDx] = normalize(decodeNormal(imageLoad(cacheNormalImage, innerCacheBlockCoord).xy));
							groupCacheIndex[localIDx] = uint(imageLoad(cacheOffsetImage, innerCacheBlockCoord).r - 1);
						}
					}

					memoryBarrierShared();
					barrier();
					
					if(j < vertexNumber )
					{
						for(uint m = 0; m < GIINDEXWORKGROUPSIZE; m++)
						{
							if(l + m < groupCacheNumber)
							{
								float weight = max(distance(groupCachePositions[m], vertexPosition), 0.0) / max(dot(vertexNormal, groupCacheNormals[m]), 0.00001);

								if(weight < weights[maximumIndex])
								{
									indices[maximumIndex] = groupCacheIndex[m];
									weights[maximumIndex] = weight;
									
									maximumIndex = 0;
									for(int n = 0; n < 8; n++)
									{
										//int compareVal = int(sign(int(weights[n] - weights[maximumIndex])));
										//maximumIndex = ((compareVal + 1) / 2) * n + ((-compareVal + 1) / 2) * maximumIndex;
										
										if(weights[maximumIndex] < weights[n])
										{
											maximumIndex = n;
										}
									}
								}
							}
						}
					}

					memoryBarrierShared();
					barrier();
				}
			}
			
			if(j < vertexNumber && texCoord.x < vertexTilePixelNumber.x && texCoord.y < vertexTilePixelNumber.y)
			{
				uint indexOffset = 8 * (texCoord.y * vertexTilePixelNumber.x + texCoord.x);
				for(uint k = 0; k < 8; k++)
				{
					specularCacheIndices[indexOffset + k] = indices[k];
				}
			}
		}
	}
}