#version 440 core

#define THREADTILESIZE 16
#define WORKGROUPSIZE (THREADTILESIZE * THREADTILESIZE)
#define TILESIZE 16
#define TILEPIXELPERTHREAD ((TILESIZE + THREADTILESIZE - 1) / THREADTILESIZE)
#define LIGHTTUBEBINDINGPOINT 0

#define INT32_MAX 2147483647
#define PI 3.14159265359
#define PI_HALF (PI * 0.5)
#define NORMALPHIQ 7
#define NORMALTHETAQ 3
#define DEPTHQ 2

#include "../../../../include/Shader/Shaderincludes/CameraUBO.glslh"
#include "../../../../include/Shader/Shaderincludes/IndirectLightCollision.glslh"

layout(location = 0) uniform sampler2D gBufferDepthSampler;
layout(location = 1) uniform sampler2D gBufferNormalSampler;
layout(location = 2) uniform sampler2D gBufferMaterialSampler;
layout(location = 3) uniform sampler2D gBufferLinearDepthSampler;

layout(r32f, binding = 0) writeonly uniform image2D edgeCacheOffsetImage;
layout(rgba32f, binding = 1) writeonly uniform image2D edgeCachePositionImage;
layout(rgba32f, binding = 2) writeonly uniform image2D edgeCacheNormalImage;
layout(r32ui, binding = 3) writeonly uniform uimage2D cacheAtomicIndexSampler;

uint depthToBin(in float depth, in uint minDepth, in uint maxDepth)
{
	float ftlMinDepth = uintBitsToFloat(minDepth);
	float ftlMaxDepth = uintBitsToFloat(maxDepth);
	return uint(((depth - ftlMinDepth) / (ftlMaxDepth - ftlMinDepth)) * DEPTHQ);
}

uint normalToBin(in vec3 normal)
{
	uint phiBin = uint(((atan(normal.y, normal.x) + PI) / (2.0 * PI)) * NORMALPHIQ);
	uint thetaBin = uint((normal.z + 0.9999) * 0.5 * NORMALTHETAQ);//[-PI/2,PI/2] --> [0,PI]
	
	return phiBin + NORMALPHIQ * thetaBin;
}

vec3 binToNormal(in uint bin)
{
	uint thetaBin = bin / NORMALPHIQ;
	uint phiBin = bin - (thetaBin * NORMALPHIQ);

	vec3 resultNormal;
	
	float phi = ((phiBin / float(NORMALPHIQ)) * 2.0 - 1.0) * PI;
	resultNormal.xy = vec2(cos(phi), sin(phi));
	resultNormal.z = ((float(thetaBin) * (PI / 3.0) + (float(thetaBin) + 1) * (PI / 3.0)) * 0.5 - PI_HALF) / PI_HALF;
	
	return resultNormal;
}

layout(local_size_x = THREADTILESIZE, local_size_y = THREADTILESIZE) in;

shared vec3 groupPosition[WORKGROUPSIZE];
shared vec3 groupNormals[WORKGROUPSIZE];
shared vec2 groupMaterial[WORKGROUPSIZE];
shared float groupSummedPixelNumber[WORKGROUPSIZE];
shared int groupNormalBin[NORMALPHIQ * NORMALTHETAQ];//rubics cube normal directions
shared uint groupMinDepth;
shared uint groupMaxDepth;
shared uint groupChoosenDepthBin;
shared uint groupMaxNormalBinID;
shared uint groupMaxNormalBinVotes;

void main()
{
	const uint idx = gl_GlobalInvocationID.x;
	const uint localIDx = gl_LocalInvocationIndex;
	const uvec2 localIDxVec = gl_LocalInvocationID.xy;
	
	const uvec2 tileNumber = (uvec2(width, height) + uvec2(TILESIZE - 1)) / TILESIZE;
	const uint tilesPerGroup = (tileNumber.x * tileNumber.y + gl_NumWorkGroups.x - 1) / gl_NumWorkGroups.x;
	const uint tileStartIndex = gl_WorkGroupID.x * tilesPerGroup;
	const uint tileEndIndex = tileStartIndex + tilesPerGroup;

	const uvec2 tilePixelStartIndex = localIDxVec * TILEPIXELPERTHREAD;

	for(uint i = tileStartIndex; i < tileEndIndex; i++)
	{
		ivec2 blockCoord = ivec2(mod(i, tileNumber.x), i / tileNumber.x);
		
		if(localIDx == 0)
		{
			groupMinDepth = 0xFFFFFFFF;
			groupMaxDepth = 0;

			for(uint j = 0; j < (NORMALPHIQ * NORMALTHETAQ); j++)
			{
				groupNormalBin[j] = 0;
			}
		}
		
		memoryBarrierShared();
		barrier();

		uint depthBinCache[TILEPIXELPERTHREAD * TILEPIXELPERTHREAD];
		for(uint j = 0; j < (TILEPIXELPERTHREAD * TILEPIXELPERTHREAD); j++)
		{
			ivec2 texCoord = TILESIZE * blockCoord + ivec2(tilePixelStartIndex) + ivec2(mod(j, TILEPIXELPERTHREAD), j / TILEPIXELPERTHREAD);

			float linearDepth = texelFetch(gBufferLinearDepthSampler, texCoord, 0).r;

			if(linearDepth < far)
			{
				atomicMin(groupMinDepth, floatBitsToUint(linearDepth));
				atomicMax(groupMaxDepth, floatBitsToUint(linearDepth));
				
				depthBinCache[j] = floatBitsToUint(linearDepth);
			}
			else
			{
				depthBinCache[j] = INT32_MAX - 1;
			}
		}

		memoryBarrierShared();
		barrier();
		
		uint normalBinCache[TILEPIXELPERTHREAD * TILEPIXELPERTHREAD];
		vec3 normalCache[TILEPIXELPERTHREAD * TILEPIXELPERTHREAD];
		
		for(uint j = 0; j < (TILEPIXELPERTHREAD * TILEPIXELPERTHREAD); j++)
		{
			ivec2 texCoord = TILESIZE * blockCoord + ivec2(tilePixelStartIndex) + ivec2(mod(j, TILEPIXELPERTHREAD), j / TILEPIXELPERTHREAD);
			
			vec3 normal = texelFetch(gBufferNormalSampler, texCoord, 0).xyz * 2.0 - 1.0;

			normalCache[j] = normal;
			normalBinCache[j] = normalToBin(normal);
			
			atomicAdd(groupNormalBin[normalBinCache[j]], 1);
			
			depthBinCache[j] = depthToBin(uintBitsToFloat(depthBinCache[j]), groupMinDepth, groupMaxDepth);
		}

		uint vertexNumber = 0;
		
		do
		{
			memoryBarrierShared();
			barrier();
			
			if(localIDx == 0)
			{
				groupMaxNormalBinID = INT32_MAX;
				groupMaxNormalBinVotes = 0;
				groupChoosenDepthBin = INT32_MAX;
				
				for(uint j = 0; j < (NORMALPHIQ * NORMALTHETAQ); j++)
				{
					if(groupNormalBin[j] > groupMaxNormalBinVotes)
					{
						groupMaxNormalBinVotes = groupNormalBin[j];
						groupMaxNormalBinID = j;
					}
				}
			}

			memoryBarrierShared();
			barrier();
			
			if(0 < groupMaxNormalBinVotes /*&& groupMaxNormalBinVotes < (TILESIZE * TILESIZE)*/)
			{
				float summedPixels = 0.0;
				vec3 summedPosition = vec3(0.0);
				vec3 summedNormals = vec3(0.0);
				vec2 summedMaterials = vec2(0.0);
				for(uint j = 0; j < (TILEPIXELPERTHREAD * TILEPIXELPERTHREAD); j++)
				{
					ivec2 texCoord = TILESIZE * blockCoord + ivec2(tilePixelStartIndex) + ivec2(mod(j, TILEPIXELPERTHREAD), j / TILEPIXELPERTHREAD);
					vec2 texCoordNormalized = texCoord / vec2(width, height);
					
					if(normalBinCache[j] == groupMaxNormalBinID)
					{
						if(groupChoosenDepthBin == INT32_MAX && depthBinCache[j] != INT32_MAX - 1)
						//if(depthBinCache[j] != INT32_MAX - 1)
						{
							atomicCompSwap(groupChoosenDepthBin, INT32_MAX, depthBinCache[j]);
						}

						if(depthBinCache[j] == groupChoosenDepthBin)
						{
							float depth = texelFetch(gBufferDepthSampler, texCoord, 0).r;
							
							if(depth < 0.9999)
							{
								vec4 position3D = invViewProjectionMatrix * (vec4(texCoordNormalized, depth, 1.0) * 2.0 - 1.0);
								position3D /= position3D.w;
								
								summedPosition += position3D.xyz;
								summedNormals += normalCache[j];
								summedMaterials += texture(gBufferMaterialSampler, texCoordNormalized).ga;//texelFetch(gBufferMaterialSampler, texCoord, 0).ga;//texture(gBufferMaterialSampler, texCoordNormalized).ga;//WHY DO I NEED TEXTURE HERE AND NOT TEXELFETCH?!
								
								summedPixels++;
							}
							
							depthBinCache[j] = INT32_MAX - 1;
							atomicAdd(groupNormalBin[groupMaxNormalBinID], -1);
						}
					}
				}
				
				groupPosition[localIDx] = summedPosition;
				groupNormals[localIDx] = summedNormals;
				groupMaterial[localIDx] = summedMaterials;
				groupSummedPixelNumber[localIDx] = summedPixels;

				memoryBarrierShared();
				barrier();
				
				float resultPixelCounter = 0.0;
				vec3 resultPosition = vec3(0.0);
				vec3 resultNormals = vec3(0.0);
				vec2 resultMaterials = vec2(0.0);
				
				for(uint j = 0; j < THREADTILESIZE; j++)//parallel scan should be more efficient here
				{
					uint index = localIDx * THREADTILESIZE + j;
					if(index < THREADTILESIZE * THREADTILESIZE && groupSummedPixelNumber[index] > 0)
					{
						resultPixelCounter += groupSummedPixelNumber[index];
						resultPosition += groupPosition[index];
						resultNormals += groupNormals[index];
						resultMaterials += groupMaterial[index];
					}
				}
				
				memoryBarrierShared();
				barrier();
				
				groupSummedPixelNumber[localIDx] = resultPixelCounter;
				groupPosition[localIDx] = resultPosition;
				groupNormals[localIDx] = resultNormals;
				groupMaterial[localIDx] = resultMaterials;
				
				memoryBarrierShared();
				barrier();
				
				if(localIDx == 0)
				{
					resultPixelCounter = 0.0;
					resultPosition = vec3(0.0);
					resultNormals = vec3(0.0);
					resultMaterials = vec2(0.0);
				
					for(uint j = 0; j < THREADTILESIZE; j++)//parallel scan should be more efficient here
					{
						if(groupSummedPixelNumber[j] > 0)
						{
							resultPixelCounter += groupSummedPixelNumber[j];
							resultPosition += groupPosition[j];
							resultNormals += groupNormals[j];
							resultMaterials += groupMaterial[j];
						}
					}
				
					resultPosition /= resultPixelCounter;
					resultNormals = normalize(resultNormals / resultPixelCounter);
					resultMaterials /= resultPixelCounter;

					ivec2 texCoord = int(TILESIZE) * blockCoord + ivec2(mod(vertexNumber, TILESIZE), vertexNumber / TILESIZE);
					
					vec4 projCoord = viewProjectionMatrix * vec4(resultPosition, 1.0);
					projCoord /= projCoord.w;
					ivec2 projTexCoord = ivec2((projCoord.xy * 0.5 + 0.5) * ivec2(width, height));
					
					float collisionSolidAngle = specularCacheSolidAngle(0.1, resultMaterials.g);
					vec3 reflectRay = normalize(reflect(normalize(resultPosition - eyePos.xyz), resultNormals));
					float cacheIndirectLightDistance;
					
					//if(indirectLightTubeCollision(resultPosition, reflectRay, collisionSolidAngle, 0, cacheIndirectLightDistance))
					{
						imageStore(edgeCacheOffsetImage, texCoord, vec4(1.0));
						imageStore(edgeCachePositionImage, texCoord, vec4(resultPosition, resultMaterials.r));
						imageStore(edgeCacheNormalImage, texCoord, vec4(resultNormals, resultMaterials.g));
						vertexNumber++;
					}
				}
			}
			else if(localIDx == 0)
			{
				groupNormalBin[groupMaxNormalBinID] = 0;
			}
		} while(groupMaxNormalBinVotes > 0);

		if(localIDx == 0)
		{
			imageStore(cacheAtomicIndexSampler, blockCoord, uvec4(vertexNumber));
		}
		
		memoryBarrierShared();
		barrier();
		
		/*
		for(uint j = 0; j < (TILEPIXELPERTHREAD * TILEPIXELPERTHREAD); j++)
		{
			ivec2 texCoord = TILESIZE * blockCoord + ivec2(tilePixelStartIndex) + ivec2(mod(j, TILEPIXELPERTHREAD), j / TILEPIXELPERTHREAD);
			
			imageStore(edgeCachePositionImage, texCoord, vec4(abs(float(mod(blockCoord.y, 2) - mod(blockCoord.x, 2)))));
		}*/
	}
}