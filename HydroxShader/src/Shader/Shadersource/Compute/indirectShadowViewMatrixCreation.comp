#version 440 core

#define SAMPLENUMBER
#define WORKGROUPSIZE 1

#include "../../HydroxShader/include/Shader/Shaderincludes/LightData.glslh"

layout(location = 0) uniform sampler2DArray indirectLightPosSampler;
layout(location = 1) uniform sampler2DArray indirectLightNormalSampler;

layout(location = 2) uniform uint rsmTexRes;

layout(std430, binding = 1) buffer reflectiveShadowLightBuffer
{
	ShadowLightData reflectiveShadowLight[];
};

layout(local_size_x = WORKGROUPSIZE) in;

void main()
{
	uint idx = gl_GlobalInvocationID.x;
	uint globalThreadNumber = gl_NumWorkGroups.x * WORKGROUPSIZE;

	vec3 camPos = vec3(0);
	vec3 camDirection = vec3(0);
	
	uint validSamples = 0;
	
	for(uint j = 0; j < SAMPLENUMBER; j++)
	{
		vec3 texCoords = vec3(mod(j, rsmTexRes) / float(rsmTexRes), float(j) / float(rsmTexRes * rsmTexRes), float(idx) / float(gl_NumWorkGroups.x));
	
		vec4 lightPos = texture(indirectLightPosSampler, texCoords);
		vec3 lightNormal = texture(indirectLightNormalSampler, texCoords).xyz * 2.0 - 1.0;
		
		if(lightPos.w == 0.0)//cancels indirect lightsources which aren't initialized, because there is no geometry behind or lit
		{
			continue;
		}
		
		validSamples++;
		
		camPos += lightPos.xyz;
		camDirection += lightNormal;
	}
	
	camPos.xyz /= validSamples;

	vec3 z = -reflectiveShadowLight[idx].light.direction.xyz;
	//vec3 z = -normalize(camDirection.xyz / validSamples);
	
	//camPos.xyz += z * 0.1;
	
	vec3 upVector = vec3(0, 1, 0);
	if(upVector == z)
	{
		upVector += vec3(0.0001);
	}
	
	vec3 x = normalize(cross(upVector, z));
	vec3 y = normalize(cross(z, x));

	mat4 viewMatrix = mat4(x.x, y.x, z.x, 0.0,
												 x.y, y.y, z.y, 0.0,
												 x.z, y.z, z.z, 0.0,
												 vec4(0.0));
												 
	viewMatrix[3] = viewMatrix[0] * -camPos.x + viewMatrix[1] * -camPos.y + viewMatrix[2] * -camPos.z + viewMatrix[3];
	
	reflectiveShadowLight[idx].lightView = viewMatrix;
}