#version 440 core

#define WORKGROUPSIZE 128

#include "../../../../include/Shader/Shaderincludes/CameraUBO.glslh"

layout(r32f, binding = 0) uniform image2D cacheOffsetBuffer;

layout(location = 0) uniform uint stride;
layout(location = 1) uniform uint perWorkGroupSampleRange;
layout(location = 2) uniform uint pixelPerThread;

layout(local_size_x = WORKGROUPSIZE) in;

shared float groupOffsets[WORKGROUPSIZE];

void main()
{
	uint idx = gl_GlobalInvocationID.x;
	uint localIDX = gl_LocalInvocationID.x;

	const uint globalThreadNumber = gl_NumWorkGroups.x * WORKGROUPSIZE;
	
	for(uint i = 0; i < pixelPerThread; i++)
	{
		uint index = stride * (idx + i * globalThreadNumber) - 1;
		
		float a = 0.0;
		
		if(index < width * height)
		{
			a = imageLoad(cacheOffsetBuffer, ivec2(mod(index, width), index / width)).r;
		}

		groupOffsets[localIDX] = a;
		
		for(uint j = 2; j <= perWorkGroupSampleRange; j *= 2)//start with j = 1 because the threads start at every second pixel and are loading the offsets tight
		//for(uint j = 64; j <= perWorkGroupSampleRange; j *= 2)//start with j = 1 because the threads start at every second pixel and are loading the offsets tight
		{
			uint samplingDistance = uint(perWorkGroupSampleRange / float(j));
			uint activeThread = uint(mod(localIDX + samplingDistance, 2 * samplingDistance));

			float newOffset = 0.0;
			
			memoryBarrierShared();
			barrier();
			
			if(activeThread == 0 && localIDX - samplingDistance >= 0)
			{
				newOffset = groupOffsets[localIDX - samplingDistance];
			}

			barrier();
			
			groupOffsets[localIDX] += newOffset;
		}
		
		if(index < width * height)
		{
			imageStore(cacheOffsetBuffer, ivec2(mod(index, width), index / width), vec4(groupOffsets[localIDX]));
		}
	}
}