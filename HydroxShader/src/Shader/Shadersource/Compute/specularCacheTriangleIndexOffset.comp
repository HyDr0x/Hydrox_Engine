#version 440 core

#include "../../../../include/Shader/Shaderincludes/CameraUBO.glslh"

#define WORKGROUPSIZE 128

layout(r16ui, binding = 0) readonly uniform uimage2D voronoiDiagramImage;
layout(r32f, binding = 1) writeonly uniform image2D triangleIndexImage;

layout(local_size_x = WORKGROUPSIZE) in;

void main()
{
	uint idx = gl_GlobalInvocationID.x;

	const uint pixelNumber = width * height;
	const uint pixelPerThread = uint(ceil(float(pixelNumber) / float(WORKGROUPSIZE * gl_NumWorkGroups.x)));
	const uint pixelOffset = idx * pixelPerThread;
	const uint pixelEnd = pixelOffset + pixelPerThread;
	
	for(uint i = pixelOffset; i < pixelEnd; i++)
	{
		ivec2 texCoord = ivec2(mod(i, width), i / width);
		
		if(texCoord.y + 1 >= height) continue;
		
		int indices[4];
		
		indices[0] = int(imageLoad(voronoiDiagramImage, texCoord).r);
		indices[1] = int(imageLoad(voronoiDiagramImage, ivec2(texCoord.x + 1, texCoord.y)).r);
		indices[2] = int(imageLoad(voronoiDiagramImage, ivec2(texCoord.x + 1, texCoord.y + 1)).r);
		indices[3] = int(imageLoad(voronoiDiagramImage, ivec2(texCoord.x, texCoord.y + 1)).r);

		uint triangleCounter = 0;
		for(uint i = 0; i < 4; i += 2)//only need two tries! sample booth triangles in counter clockwise order to avoid culling!
		{
			uint index1 = uint(mod(i + 1, 4));
			uint index2 = uint(mod(i + 2, 4));
			if(indices[i] != indices[index1] && indices[i] != indices[index2] && indices[index1] != indices[index2])
			{
				triangleCounter++;
			}
		}
		
		imageStore(triangleIndexImage, texCoord, vec4(triangleCounter));
	}
}