#version 440 core

#define WORKGROUPSIZE 64
#define TILESIZE 16
#define INT32_MAX 2147483647
#define CACHEROUNDS 1

#include "../../../../include/Shader/Shaderincludes/CameraUBO.glslh"

layout(r32f, binding = 0) readonly uniform image2D cacheOffsetImage;
layout(rgba32f, binding = 1) readonly uniform image2D cachePositionImage;
layout(rgba32f, binding = 2) readonly uniform image2D cacheNormalImage;
layout(r32ui, binding = 3) readonly uniform uimage2D cacheNumberPerTileImage;

layout(r32f, binding = 4) readonly uniform image2D vertexOffsetImage;
layout(rgba32f, binding = 5) readonly uniform image2D vertexPositionImage;
layout(rgba32f, binding = 6) readonly uniform image2D vertexNormalImage;
layout(r32ui, binding = 7) readonly uniform uimage2D vertexNumberPerTileImage;

layout(std430, binding = 0) buffer vertexPositionBuffer
{
	vec4 vertexPositions[];
};

layout(std430, binding = 1) buffer vertexNormalBuffer
{
	vec4 vertexNormals[];
};

layout(std430, binding = 2) buffer specularCachePositionBuffer
{
	vec4 specularCachePositions[];
};

layout(std430, binding = 3) buffer specularCacheNormalMaterialBuffer
{
	vec4 specularCacheNormals[];
};

layout(std430, binding = 4) buffer specularCacheIndices0Buffer
{
	vec4 specularCacheIndices0[];
};

layout(std430, binding = 5) buffer specularCacheIndices1Buffer
{
	vec4 specularCacheIndices1[];
};

layout(location = 0) uniform uint borderVertexNumber;

layout(local_size_x = WORKGROUPSIZE) in;

shared vec3 groupCachePositions[WORKGROUPSIZE];
shared vec3 groupCacheNormals[WORKGROUPSIZE];
shared uint groupCacheIndex[WORKGROUPSIZE];
shared uint groupCacheNumberPerTile[CACHEROUNDS * 8];
shared uint groupCacheNumber;

void main()
{
	const uint cacheNumber = uint(imageLoad(cacheOffsetImage, ivec2(width - 1, height - 1)).r);

	const uint idx = gl_GlobalInvocationID.x;
	const uint localIDx = gl_LocalInvocationIndex;

	const uvec2 tileNumber = (uvec2(width, height) + uvec2(TILESIZE - 1)) / TILESIZE;
	const uint tilesPerGroup = (tileNumber.x * tileNumber.y + gl_NumWorkGroups.x - 1) / gl_NumWorkGroups.x;
	const uint tileStartIndex = gl_WorkGroupID.x * tilesPerGroup;
	const uint tileEndIndex = tileStartIndex + tilesPerGroup;

	for(uint i = tileStartIndex; i < tileEndIndex; i++)
	{
		ivec2 blockCoord = ivec2(mod(i, tileNumber.x), i / tileNumber.x);
		
		const uint vertexNumber = imageLoad(vertexNumberPerTileImage, blockCoord).r;
		const uint verticesPerThread = (vertexNumber + WORKGROUPSIZE - 1) / WORKGROUPSIZE;
		const uint vertexStartIndex = verticesPerThread * localIDx;
		const uint vertexEndIndex = vertexStartIndex + verticesPerThread;
		
		for(uint j = vertexStartIndex; j < vertexEndIndex; j++)
		{
			ivec2 texCoord = blockCoord * TILESIZE + ivec2(mod(j, TILESIZE), j / TILESIZE);

			vec3 vertexPosition;
			vec3 vertexNormal;
			
			if(texCoord.x < width && texCoord.y < height)
			{
				vertexPosition = imageLoad(vertexPositionImage, texCoord).xyz;
				vertexNormal = normalize(imageLoad(vertexNormalImage, texCoord).xyz);
			}
			
			uint indices[8] = uint[](INT32_MAX, INT32_MAX, INT32_MAX, INT32_MAX, INT32_MAX, INT32_MAX, INT32_MAX, INT32_MAX);
			float weights[8] = float[](INT32_MAX, INT32_MAX, INT32_MAX, INT32_MAX, INT32_MAX, INT32_MAX, INT32_MAX, INT32_MAX);
			
			uint maximumIndex = 0;
			
			for(uint k = 0; k < CACHEROUNDS; k++)
			{
				const uint cacheBlockNumber = max(k * 8, 1);
				const uint sideLength = 2 * k;
				
				const uint blocksPerThread = (cacheBlockNumber + WORKGROUPSIZE - 1) / WORKGROUPSIZE;
				const uint startBlockIndex = localIDx * blocksPerThread;
				const uint endBlockIndex = startBlockIndex + blocksPerThread;
				
				for(uint l = startBlockIndex; l < endBlockIndex; l++)
				{
					ivec2 cacheNumberTexCoord = blockCoord;
					if(k > 0)
					{
						if(l < k * 4)//smaller than cacheBlockNumber / 2
						{
							cacheNumberTexCoord += (ivec2(min(l, sideLength), max(int(l) - int(sideLength), 0)) - ivec2(k));
						}
						else
						{
							cacheNumberTexCoord += (ivec2(max(cacheBlockNumber - sideLength - l, 0), min(cacheBlockNumber - l, sideLength)) - ivec2(k));
						}
					}
					
					uint blockCacheNumber = 0;
					if(l < cacheBlockNumber &&
						 0 <= cacheNumberTexCoord.x && cacheNumberTexCoord.x < tileNumber.x &&
						 0 <= cacheNumberTexCoord.y && cacheNumberTexCoord.y < tileNumber.y)
					{
						blockCacheNumber = imageLoad(cacheNumberPerTileImage, cacheNumberTexCoord).r;
					}
					
					groupCacheNumberPerTile[l] = blockCacheNumber;
				}

				memoryBarrierShared();
				barrier();

				if(localIDx == 0)
				{
					uint tmpCacheNumber = 0;
					for(uint l = 0; l < cacheBlockNumber; l++)
					{
						tmpCacheNumber += groupCacheNumberPerTile[l];
					}
					
					groupCacheNumber = tmpCacheNumber;
				}
				
				memoryBarrierShared();
				barrier();

				const uint cacheLoopNumber = WORKGROUPSIZE * ((groupCacheNumber + WORKGROUPSIZE - 1) / WORKGROUPSIZE);
				for(uint l = 0; l < cacheLoopNumber; l += WORKGROUPSIZE)
				{
					const uint cacheIndex = l + localIDx;

					if(j < vertexNumber && cacheIndex < groupCacheNumber)
					{
						uint cacheBlockIndex;
						uint roundCacheStartIndex = 0;
						for(uint m = 0; m < cacheBlockNumber; m++)
						{
							roundCacheStartIndex += groupCacheNumberPerTile[m];
							if(roundCacheStartIndex > cacheIndex)
							{
								cacheBlockIndex = m;
								break;
							}
						}

						ivec2 cacheNumberTexCoord = blockCoord;
						if(k > 0)
						{
							if(cacheBlockIndex < k * 4)//smaller than cacheBlockNumber / 2
							{
								cacheNumberTexCoord += (ivec2(min(cacheBlockIndex, sideLength), max(cacheBlockIndex - sideLength, 0)) - ivec2(k));
							}
							else
							{
								cacheNumberTexCoord += (ivec2(max(cacheBlockNumber - sideLength - cacheBlockIndex, 0), min(cacheBlockNumber - cacheBlockIndex, sideLength)) - ivec2(k));
							}
						}
						
						uint innerBlockCacheIndex = cacheIndex - (roundCacheStartIndex - groupCacheNumberPerTile[cacheBlockIndex]);
						ivec2 innerCacheBlockCoord = cacheNumberTexCoord * TILESIZE + ivec2(mod(innerBlockCacheIndex, TILESIZE), innerBlockCacheIndex / TILESIZE);

						if(0 <= innerCacheBlockCoord.x && innerCacheBlockCoord.x < width &&
							 0 <= innerCacheBlockCoord.y && innerCacheBlockCoord.y < height)
						{
							groupCachePositions[localIDx] = imageLoad(cachePositionImage, innerCacheBlockCoord).xyz;
							groupCacheNormals[localIDx] = imageLoad(cacheNormalImage, innerCacheBlockCoord).xyz;
							groupCacheIndex[localIDx] = uint(imageLoad(cacheOffsetImage, innerCacheBlockCoord).r - 1);
						}
						/*else
						{
							groupCachePositions[localIDx] = vec3(0);
							groupCacheNormals[localIDx] = vec3(0);
							groupCacheIndex[localIDx] = 0;
						}*/
					}
					
					memoryBarrierShared();
					barrier();
					
					if(j < vertexNumber && texCoord.x < width && texCoord.y < height)
					{
						for(uint m = 0; m < WORKGROUPSIZE; m++)
						{
							if(m + l < groupCacheNumber)
							{
								vec3 cachePosDistance = groupCachePositions[m] - vertexPosition;
								float angle = dot(vertexNormal, groupCacheNormals[m]);
								float weight = max(length(cachePosDistance), 0.0) / max(pow(angle, 1.0), 0.00001);

								if(weight < weights[maximumIndex])
								{
									indices[maximumIndex] = groupCacheIndex[m];
									weights[maximumIndex] = weight;
									
									maximumIndex = 7;
									for(int n = 0; n < 7; n++)
									{
										//int compareVal = int(sign(int(weights[n] - weights[maximumIndex])));
										//maximumIndex = ((compareVal + 1) / 2) * n + ((-compareVal + 1) / 2) * maximumIndex;
										
										if(weights[maximumIndex] < weights[n])
										{
											maximumIndex = n;
										}
									}
								}
							}
						}
					}
					
					memoryBarrierShared();
					barrier();
				}
			}
		
			if(j < vertexNumber && texCoord.x < width && texCoord.y < height)
			{
				for(uint k = 0; k < 8; k++)
				{
					if(indices[k] < INT32_MAX)
					{
						vec4 projCachePos = viewProjectionMatrix * specularCachePositions[indices[k]];
						projCachePos /= projCachePos.w;
						ivec2 cacheProjCoord = ivec2((vec2(projCachePos.xy) * 0.5 + 0.5) * ivec2(width, height));
						
						cacheProjCoord /= TILESIZE;
						
						if(cacheProjCoord != blockCoord)
						{
							//indices[k] = INT32_MAX;
						}
					}
				}
			
				const uint vertexOffset = borderVertexNumber + uint(imageLoad(vertexOffsetImage, texCoord).r - 1);
				specularCacheIndices0[vertexOffset] = vec4(indices[0], indices[1], indices[2], indices[3]);
				specularCacheIndices1[vertexOffset] = vec4(indices[4], indices[5], indices[6], indices[7]);
				
			}
		}
	}
}