#version 440 core

#define THREADTILESIZE 16
#define WORKGROUPSIZE (THREADTILESIZE * THREADTILESIZE)
#define TILESIZE 16
#define TILEPIXELPERTHREAD ((TILESIZE + THREADTILESIZE - 1) / THREADTILESIZE)

#define PI 3.14159265359
#define PI_HALF (PI * 0.5)
#define NORMALPHIQ 7
#define NORMALTHETAQ 5

#include "../../HydroxShader/include/Shader/Shaderincludes/CameraUBO.glslh"

layout(location = 0) uniform sampler2D gBufferDepthSampler;
layout(location = 1) uniform sampler2D gBufferNormalSampler;
layout(location = 2) uniform sampler2D gBufferMaterialSampler;

layout(r32f, binding = 0) uniform writeonly image2D edgeCacheOffsetImage;
layout(rgba32f, binding = 1) uniform writeonly image2D edgeCachePositionImage;
layout(rgba32f, binding = 2) uniform writeonly image2D edgeCacheNormalImage;

uint normalToBin(in vec3 normal)
{
	uint phiBin = uint(((atan(normal.y, normal.x) + PI) / (2.0 * PI)) * NORMALPHIQ);
	uint thetaBin = uint((normal.z + 0.9999) * 0.5 * NORMALTHETAQ);//[-PI/2,PI/2] --> [0,PI]
	
	return phiBin + NORMALPHIQ * thetaBin;
}

vec3 binToNormal(in uint bin)
{
	uint thetaBin = bin / NORMALPHIQ;
	uint phiBin = bin - (thetaBin * NORMALPHIQ);

	vec3 resultNormal;
	
	float phi = ((phiBin / float(NORMALPHIQ)) * 2.0 - 1.0) * PI;
	resultNormal.xy = vec2(cos(phi), sin(phi));
	resultNormal.z = ((float(thetaBin) * (PI / 3.0) + (float(thetaBin) + 1) * (PI / 3.0)) * 0.5 - PI_HALF) / PI_HALF;
	
	return resultNormal;
}

layout(local_size_x = THREADTILESIZE, local_size_y = THREADTILESIZE) in;

shared vec3 groupPosition[WORKGROUPSIZE];
shared vec3 groupNormals[WORKGROUPSIZE];
shared vec2 groupMaterial[WORKGROUPSIZE];
shared float groupSummedPixelNumber[WORKGROUPSIZE];
shared uint groupNormalBin[NORMALPHIQ * NORMALTHETAQ];//rubics cube normal directions
shared uint groupMaxNormalBinID;
shared uint groupMaxNormalBinVotes;

void main()
{
	const uint idx = gl_GlobalInvocationID.x;
	const uint localIDx = gl_LocalInvocationIndex;
	const uvec2 localIDxVec = gl_LocalInvocationID.xy;
	
	const uvec2 tileNumber = (uvec2(width, height) + uvec2(TILESIZE - 1)) / TILESIZE;
	const uint tilesPerGroup = (tileNumber.x * tileNumber.y + gl_NumWorkGroups.x - 1) / gl_NumWorkGroups.x;
	const uint tileStartIndex = gl_WorkGroupID.x * tilesPerGroup;
	const uint tileEndIndex = tileStartIndex + tilesPerGroup;

	const uvec2 tilePixelStartIndex = localIDxVec * TILEPIXELPERTHREAD;

	for(uint i = tileStartIndex; i < tileEndIndex; i++)
	{
		ivec2 blockCoord = ivec2(mod(i, tileNumber.x), i / tileNumber.x);
		
		if(localIDx == 0)
		{
			for(uint j = 0; j < (NORMALPHIQ * NORMALTHETAQ); j++)
			{
				groupNormalBin[j] = 0;
			}
		}
		
		memoryBarrierShared();
		barrier();
		
		uint normalBinCache[TILEPIXELPERTHREAD * TILEPIXELPERTHREAD];
		vec3 normalCache[TILEPIXELPERTHREAD * TILEPIXELPERTHREAD];
		
		for(uint j = 0; j < (TILEPIXELPERTHREAD * TILEPIXELPERTHREAD); j++)
		{
			ivec2 texCoord = TILESIZE * blockCoord + ivec2(tilePixelStartIndex) + ivec2(mod(j, TILEPIXELPERTHREAD), j / TILEPIXELPERTHREAD);
			
			vec3 normal = texelFetch(gBufferNormalSampler, texCoord, 0).xyz * 2.0 - 1.0;

			normalCache[j] = normal;
			normalBinCache[j] = normalToBin(normal);
			
			atomicAdd(groupNormalBin[normalBinCache[j]], 1);
		}

		do
		{
			memoryBarrierShared();
			barrier();

			if(localIDx == 0)
			{
				groupMaxNormalBinVotes = 0;
				
				for(uint j = 0; j < (NORMALPHIQ * NORMALTHETAQ); j++)
				{
					if(groupNormalBin[j] > groupMaxNormalBinVotes)
					{
						groupMaxNormalBinVotes = groupNormalBin[j];
						groupMaxNormalBinID = j;
					}
				}
				
				groupNormalBin[groupMaxNormalBinID] = 0;
			}

			memoryBarrierShared();
			barrier();
			
			if(groupMaxNormalBinVotes > 0 && groupMaxNormalBinVotes < (TILESIZE * TILESIZE))
			{
				float pixelCounter = 0.0;
				vec3 summedPosition = vec3(0.0);
				vec3 summedNormals = vec3(0.0);
				vec2 summedMaterials = vec2(0.0);
				for(uint j = 0; j < (TILEPIXELPERTHREAD * TILEPIXELPERTHREAD); j++)
				{
					ivec2 texCoord = TILESIZE * blockCoord + ivec2(tilePixelStartIndex) + ivec2(mod(j, TILEPIXELPERTHREAD), j / TILEPIXELPERTHREAD);
					vec2 texCoordNormalized = texCoord / vec2(width, height);
					
					if(normalBinCache[j] == groupMaxNormalBinID)
					{
						float depth = texelFetch(gBufferDepthSampler, texCoord, 0).r;
						vec4 position3D = invViewProjectionMatrix * (vec4(texCoordNormalized, depth, 1.0) * 2.0 - 1.0);
						position3D /= position3D.w;
						
						summedPosition += position3D.xyz;
						summedNormals += normalCache[j];
						summedMaterials += texelFetch(gBufferMaterialSampler, texCoord, 0).ba;
						
						pixelCounter++;
					}
				}
				
				groupPosition[localIDx] = summedPosition;
				groupNormals[localIDx] = summedNormals;
				groupMaterial[localIDx] = summedMaterials;
				groupSummedPixelNumber[localIDx] = pixelCounter;

				memoryBarrierShared();
				barrier();
				
				
				float resultPixelCounter = 0.0;
				vec3 resultPosition = vec3(0.0);
				vec3 resultNormals = vec3(0.0);
				vec2 resultMaterials = vec2(0.0);
				
				for(uint j = 0; j < THREADTILESIZE; j++)//parallel scan should be more efficient here
				{
					uint index = localIDx * THREADTILESIZE + j;
					if(index < THREADTILESIZE * THREADTILESIZE && groupSummedPixelNumber[index] > 0)
					{
						resultPixelCounter += groupSummedPixelNumber[index];
						resultPosition += groupPosition[index];
						resultNormals += groupNormals[index];
						resultMaterials += groupMaterial[index];
					}
				}
				
				memoryBarrierShared();
				barrier();
				
				groupSummedPixelNumber[localIDx] = resultPixelCounter;
				groupPosition[localIDx] = resultPosition;
				groupNormals[localIDx] = resultNormals;
				groupMaterial[localIDx] = resultMaterials;
				
				memoryBarrierShared();
				barrier();
				
				if(localIDx == 0)
				{
					resultPixelCounter = 0.0;
					resultPosition = vec3(0.0);
					resultNormals = vec3(0.0);
					resultMaterials = vec2(0.0);
				
					for(uint j = 0; j < THREADTILESIZE; j++)//parallel scan should be more efficient here
					{
						if(groupSummedPixelNumber[j] > 0)
						{
							resultPixelCounter += groupSummedPixelNumber[j];
							resultPosition += groupPosition[j];
							resultNormals += groupNormals[j];
							resultMaterials += groupMaterial[j];
						}
					}
				
					resultPosition /= resultPixelCounter;
					resultNormals /= resultPixelCounter;
					resultMaterials /= resultPixelCounter;
					//vec3 resultNormal = binToNormal(groupMaxNormalBinID);
					
					vec4 projCoord = viewProjectionMatrix * vec4(resultPosition, 1.0);
					projCoord /= projCoord.w;
					ivec2 projTexCoord = ivec2((projCoord.xy * 0.5 + 0.5) * ivec2(width, height));
					
					imageStore(edgeCacheOffsetImage, projTexCoord, vec4(1.0));
					imageStore(edgeCachePositionImage, projTexCoord, vec4(resultPosition, resultMaterials.r));
					imageStore(edgeCacheNormalImage, projTexCoord, vec4(normalize(resultNormals), resultMaterials.g));
				}
			}
			
		} while(groupMaxNormalBinVotes > 0);
		
		memoryBarrierShared();
		barrier();
		/*
		for(uint j = 0; j < (TILEPIXELPERTHREAD * TILEPIXELPERTHREAD); j++)
		{
			ivec2 texCoord = TILESIZE * blockCoord + ivec2(tilePixelStartIndex) + ivec2(mod(j, TILEPIXELPERTHREAD), j / TILEPIXELPERTHREAD);
			
			imageStore(edgeCachePositionImage, texCoord, vec4(abs(float(mod(blockCoord.y, 2) - mod(blockCoord.x, 2)))));
		}*/
	}
}