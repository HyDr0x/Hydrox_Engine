#version 440 core

#define HALFRESX
#define HALFRESY
#define ROUGHNESSDIFF

#define WORKGROUPSIZE 128
#define PI 3.14159265359
#define PI_HALF (0.5 * PI)
#define LIGHTTUBEBINDINGPOINT 1

#include "../../HydroxShader/include/Shader/Shaderincludes/CameraUBO.glslh"
#include "../../HydroxShader/include/Shader/Shaderincludes/IndirectLightCollision.glslh"
#include "../../HydroxShader/include/Shader/Shaderincludes/MaterialConversion.glslh"

layout(location = 0) uniform sampler2D gBufferDepthSampler;
layout(location = 1) uniform sampler2D gBufferNormalSampler;
layout(location = 2) uniform sampler2D gBufferMaterialSampler;

layout(location = 3) uniform uint reflectiveShadowMapNumber;
layout(location = 4) uniform ivec2 stepSize;

layout(r16f, binding = 0) uniform writeonly image2D cacheInnerSamplingDistanceBuffer;

layout(local_size_x = WORKGROUPSIZE) in;

void main()
{
	const uint idx = gl_GlobalInvocationID.x;

	vec3 oldPosition = vec3(0.0), newPosition;
	vec3 normal;
	float sampleDistance = 0.0;
	float oldRoughness = 0.0, roughness;
	float depth;
	
	const uint pixelPerThread = uint(ceil(HALFRESX / floor((gl_NumWorkGroups.x * WORKGROUPSIZE) / HALFRESY)));
	const uint startIndex = idx * pixelPerThread;
	const uint endIndex = startIndex + pixelPerThread;

	ivec2 texCoords = ivec2(pixelPerThread * floor(idx / HALFRESY), mod(idx, HALFRESY));

	for(uint i = startIndex; i < endIndex; i++)
	{
		if(texCoords.y >= HALFRESY && stepSize.y > 0)
		{
			texCoords.y = 0;
			sampleDistance = 0.0;
			oldPosition = vec3(0.0);
		}
			
		if(texCoords.x >= HALFRESX || texCoords.y >= HALFRESY)
		{
			return;
		}

		depth = texelFetch(gBufferDepthSampler, texCoords, 0).r;
		
		if(depth >= 0.99999)
		{
			sampleDistance = 0.0;
			oldPosition = vec3(0.0);
			texCoords += stepSize;
			continue;
		}
		
		newPosition = vec3(texCoords / vec2(HALFRESX, HALFRESY), depth) * 2.0 - 1.0;
		vec4 tmpProjPos = invViewProjectionMatrix * vec4(newPosition, 1.0);
		newPosition = tmpProjPos.xyz / tmpProjPos.w;
		
		roughness = texelFetch(gBufferMaterialSampler, texCoords, 0).b;
		
		normal = normalize(texelFetch(gBufferNormalSampler, texCoords, 0).xyz * 2.0 - 1.0);
		
		sampleDistance -= length(newPosition - oldPosition);
		
		if(sampleDistance <= 0.0 || (oldRoughness - roughness) > ROUGHNESSDIFF)
		{
			float maxSolidAngle = specularCacheSolidAngle(0.95, GGXToBlinnPhong(vec4(0, 0, roughness, 0)).w);
			
			vec3 reflectRay = normalize(reflect(normalize(newPosition - eyePos.xyz), normal));
			
			float cacheIndirectLightDistance;
			
			for(uint j = 0; j < reflectiveShadowMapNumber; j++)
			{
				if(indirectLightTubeCollision(newPosition, reflectRay, maxSolidAngle, j, cacheIndirectLightDistance))
				{
					float newSampleDistance = samplingDistance(cacheIndirectLightDistance, maxSolidAngle);
					
					imageStore(cacheInnerSamplingDistanceBuffer, texCoords, vec4(1.0));

					sampleDistance = newSampleDistance;
					
					break;
				}
			}
		}

		oldRoughness = roughness;
		oldPosition = newPosition;

		texCoords += stepSize;
	}
}