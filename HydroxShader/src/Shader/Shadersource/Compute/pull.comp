#version 440 core

#define PYRAMIDESIZE
#define WORKGROUPSIZE 128

layout(location = 0) uniform sampler2DArray loadShadowMap;
layout(r32f, binding = 0) writeonly uniform image2D writeShadowMap;

layout(location = 1) uniform uint textureSize;
layout(location = 2) uniform uint j;

layout(local_size_x = WORKGROUPSIZE) in;

void main()
{
	uint idx = gl_GlobalInvocationID.x;
	uint globalThreadNumber = gl_NumWorkGroups.x * WORKGROUPSIZE;

	uint pixelBlocksPerThread = (textureSize * textureSize) / globalThreadNumber;
	for(uint i = 0; i < pixelBlocksPerThread; i++)
	{
		uint index = idx + i * globalThreadNumber;
		ivec2 texCoord = 2 * ivec2(mod(index, textureSize), index / textureSize);
		
		float tmpDepth;
		float depth = 0.0;
		float kernelSize = 0.0;
		
		tmpDepth = texelFetch(loadShadowMap, ivec3(texCoord.x    , texCoord.y, j), 0).r;
		if(tmpDepth < 1.0)
		{
			depth += tmpDepth;
			kernelSize++;
		}
		
		tmpDepth = texelFetch(loadShadowMap, ivec3(texCoord.x + 1, texCoord.y, j), 0).r;
		if(tmpDepth < 1.0)
		{
			depth += tmpDepth;
			kernelSize++;
		}
		
		tmpDepth = texelFetch(loadShadowMap, ivec3(texCoord.x    , texCoord.y + 1, j), 0).r;
		if(tmpDepth < 1.0)
		{
			depth += tmpDepth;
			kernelSize++;
		}
		
		tmpDepth = texelFetch(loadShadowMap, ivec3(texCoord.x + 1, texCoord.y + 1, j), 0).r;
		if(tmpDepth < 1.0)
		{
			depth += tmpDepth;
			kernelSize++;
		}
		
		if(kernelSize == 0.0)
		{
			depth = 1.0;
		}
		else
		{
			depth /= kernelSize;
		}

		imageStore(writeShadowMap, ivec2(texCoord.x * 0.5, texCoord.y * 0.5), vec4(depth));
	}
}