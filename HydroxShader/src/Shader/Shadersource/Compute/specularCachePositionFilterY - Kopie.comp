#version 440 core

#define WORKGROUPSIZE 16
#define PI 3.14159265359
#define PI_HALF (0.5 * PI)

#include "../../HydroxShader/include/Shader/Shaderincludes/CameraUBO.glslh"

layout(location = 0) uniform sampler2D gBufferDepthSampler;
layout(location = 1) uniform sampler2D gBufferNormalSampler;
layout(location = 2) uniform sampler2D gBufferMaterialSampler;

layout(location = 3) uniform uint reflectiveShadowMapNumber;
layout(location = 4) uniform ivec2 stepSize;

layout(rg16f, binding = 0) uniform writeonly image2D cacheEdgeSamplingDistanceBuffer;
layout(r16f, binding = 1) uniform readonly image2D cacheInnerSamplingDistanceBuffer;
layout(r32f, binding = 2) uniform writeonly image2D cacheOffsetBuffer;
layout(r16f, binding = 3) uniform writeonly image2D cachePosMap;

layout(std430, binding = 1) buffer tubeData
{
	vec4 tubeStartPosRadius[1];
	vec4 tubeDirection[1];//not normalized, the vector length is the length of the tube
};

float specularCacheSolidAngle(float yFuncOffset, float n)
{
	return PI_HALF - asin(pow(yFuncOffset, 1.0 / n));
}

bool indirectLightTubeCollision(in vec3 cachePos, in vec3 r, in float maxSolidAngle, in uint tubeIndex, out float distance)
{
	float dotRDir = dot(r, tubeDirection[tubeIndex].xyz);
	
	vec3 trfTubeStartPos = tubeStartPosRadius[tubeIndex].xyz - cachePos;
	
	float t = (dot(r, trfTubeStartPos) * dotRDir - dot(trfTubeStartPos, tubeDirection[tubeIndex].xyz)) / (dot(tubeDirection[tubeIndex].xyz, tubeDirection[tubeIndex].xyz) - dotRDir * dotRDir);
	
	vec3 tubePos = trfTubeStartPos + clamp(t, 0.0, 1.0) * tubeDirection[tubeIndex].xyz;
	
	float lineDistance = length(tubePos);

	vec3 centerToRay = dot(tubePos, r) * r - tubePos;
	vec3 closestPoint = (tubePos + centerToRay * clamp(tubeStartPosRadius[tubeIndex].w / length(centerToRay), 0.0, 1.0));
	
	float tubeDistance = max(length(closestPoint), 0.001);

	//if we are inside the tube, we use the distance to the center
	distance = lineDistance < tubeStartPosRadius[tubeIndex].w ? length(tubePos + 0.5 * tubeDirection[tubeIndex].xyz) : tubeDistance;
	//distance = lineDistance;
	//distance = tubeDistance;
	//distance = length(cachePos - (trfTubeStartPos + 0.5 * tubeDirection[tubeIndex].xyz));
	
	float radix = 2.0;
	float base = pow(radix, floor(log(distance) / log(radix)) - 1.0);
	distance = base * floor(distance / base);
	
	return dot(normalize(closestPoint / tubeDistance), r) > cos(maxSolidAngle) && distance > 0.1;
}

float samplingDistance(float lightDistance, float maxSolidAngle)
{
	return /*0.1325 */ min(lightDistance * 2.0 * tan(maxSolidAngle), 8.0) * 0.25;
	//return min(2.0 * lightDistance * tan(maxSolidAngle), 1.0);
}

layout(local_size_x = WORKGROUPSIZE) in;

void main()
{
	const uint idx = gl_GlobalInvocationID.x;

	vec3 oldPosition = vec3(0.0), newPosition;
	vec3 normal;
	float sampleDistance = 0.0;
	float roughness;
	float depth;
	
	const uint pixelPerThread = uint(ceil(width / floor((gl_NumWorkGroups.x * WORKGROUPSIZE) / height)));
	const uint startIndex = idx * pixelPerThread;
	const uint endIndex = startIndex + pixelPerThread;

	ivec2 texCoords = stepSize * ivec2(pixelPerThread * floor(idx / height), pixelPerThread * floor(idx / width)) + (ivec2(1) - stepSize) * ivec2(mod(idx, width), mod(idx, height));

	for(uint i = startIndex; i < endIndex; i++)
	{
		if(texCoords.y >= height && stepSize.y > 0)
		{
			texCoords.y = 0;
			sampleDistance = 0.0;
			oldPosition = vec3(0.0);
		}
		
		if(texCoords.y < 0 && stepSize.y < 0)
		{
			texCoords.y = int(height - 1);
			sampleDistance = 0.0;
			oldPosition = vec3(0.0);
		}
	
		if(texCoords.x >= width || texCoords.y >= height)
		{
			return;
		}

		depth = texelFetch(gBufferDepthSampler, texCoords, 0).r;
		
		if(depth >= 0.99999)
		{
			sampleDistance = 0.0;
			oldPosition = vec3(0.0);
			texCoords += stepSize;
			continue;
		}
		
		newPosition = vec3(texCoords / vec2(width, height), depth) * 2.0 - 1.0;
		vec4 tmpProjPos = invViewProjectionMatrix * vec4(newPosition, 1.0);
		newPosition = tmpProjPos.xyz / tmpProjPos.w;
		
		roughness = texelFetch(gBufferMaterialSampler, texCoords, 0).w;
		
		normal = normalize(texelFetch(gBufferNormalSampler, texCoords, 0).xyz * 2.0 - 1.0);
		
		sampleDistance -= length(newPosition - oldPosition);
		
		if(sampleDistance <= 0.0)
		{
			float maxSolidAngle = specularCacheSolidAngle(0.5, roughness);
			float collisionSolidAngle = specularCacheSolidAngle(0.1, roughness);
			
			vec3 reflectRay = normalize(reflect(normalize(newPosition - eyePos.xyz), normal));
			
			float cacheIndirectLightDistance;
			
			for(uint j = 0; j < reflectiveShadowMapNumber; j++)
			{
				if(indirectLightTubeCollision(newPosition, reflectRay, collisionSolidAngle, j, cacheIndirectLightDistance))
				{
					float newSampleDistance = samplingDistance(cacheIndirectLightDistance, maxSolidAngle);

					if(imageLoad(cacheInnerSamplingDistanceBuffer, texCoords).x > 0.0001)
					{
						imageStore(cachePosMap, texCoords, vec4(newSampleDistance));
						imageStore(cacheOffsetBuffer, texCoords, vec4(1.0));
					}
					
					sampleDistance = newSampleDistance;
					
					break;
				}
			}
		}

		oldPosition = newPosition;
		texCoords += stepSize;
	}
}