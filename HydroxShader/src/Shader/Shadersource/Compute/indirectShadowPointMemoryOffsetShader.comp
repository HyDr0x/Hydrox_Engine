#version 440 core

#define WORKGROUPSIZE 128
#define PI 3.14159265359
//circleArea = pi * r^2 = pi * 0.5 * 0.5
#define AREAMAX (0.25 * PI)

layout(r32ui, binding = 0) readonly uniform uimage2D indexBuffer;

layout(r16ui, binding = 1) writeonly uniform uimage1D sampleNumberOffsetBuffer;

layout(location = 0) uniform samplerBuffer siteBuffer;

layout(location = 1) uniform uint resolution;

layout(location = 2) uniform uint maxSampleNumber;

layout(local_size_x = WORKGROUPSIZE) in;

void main()
{
	uint idx = gl_GlobalInvocationID.x;

	if(idx >= resolution)
	{
		return;
	}
	
	uint rowSampleNumber = 0;
	
	for(int x = 0; x < resolution; x++)
	{
		ivec2 texCoord = ivec2(x, idx);
		
		if(texCoord.x + 1 >= resolution || texCoord.y + 1 >= resolution) continue;
		
		int indices[4];
		
		indices[0] = int(imageLoad(indexBuffer, ivec2(texCoord.x, texCoord.y)).r - 1);
		indices[1] = int(imageLoad(indexBuffer, ivec2(texCoord.x + 1, texCoord.y)).r - 1);
		indices[2] = int(imageLoad(indexBuffer, ivec2(texCoord.x + 1, texCoord.y + 1)).r - 1);
		indices[3] = int(imageLoad(indexBuffer, ivec2(texCoord.x, texCoord.y + 1)).r - 1);

		uint seed = texCoord.x + resolution * texCoord.y;
		
		for(uint i = 0; i < 2; i++)//only need two tries!
		{
			uint index1 = uint(mod(i + 1, 4));
			uint index2 = uint(mod(i + 2, 4));
			if(indices[i] != indices[index1] && indices[i] != indices[index2] && indices[index1] != indices[index2])
			{
				vec2 p0 = texelFetch(siteBuffer, indices[i]).xy;
				vec2 p1 = texelFetch(siteBuffer, indices[index1]).xy;
				vec2 p2 = texelFetch(siteBuffer, indices[index2]).xy;

				if(length(vec2(0.5) - p0) < 0.5 && length(vec2(0.5) - p1) < 0.5 && length(vec2(0.5) - p2) < 0.5)
				{
					vec3 e0 = vec3(p1 - p0, 0);
					vec3 e1 = vec3(p2 - p0, 0);
					float triangleArea = 0.5 * length(cross(e0, e1));
					uint sampleNumber = uint(maxSampleNumber * (triangleArea / AREAMAX));
					rowSampleNumber += sampleNumber;
				}
			}
		}
	}
	
	imageStore(sampleNumberOffsetBuffer, int(idx), uvec4(rowSampleNumber));
}