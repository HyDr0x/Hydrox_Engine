#version 440 core

#define SAMPLENUMBER
#define PI 3.14159265359
#define EPSILON 0.00001
#define INT32_MAX 2147483647
#define WORKGROUPSIZE 128

#include "../../../../include/Shader/Shaderincludes/CameraUBO.glslh"
#include "../../../../include/Shader/Shaderincludes/Encodings.glslh"

struct DrawArraysInstanced
{
	uint count;
	uint primCount;
	uint first;
	uint baseInstance;
};

layout(location = 0) uniform sampler2D gBufferDepthSampler;
layout(location = 1) uniform sampler2D gBufferNormalSampler;
layout(location = 2) uniform sampler2D gBufferMaterialSampler;

layout(r32f, binding = 0) readonly uniform image2D cacheOffsetSampler;
layout(r32f, binding = 1) readonly uniform image2D cacheSampleDistanceSampler;

layout(std430, binding = 0) buffer specularCachePositionBuffer
{
	vec4 specularCachePositions[];
};

layout(std430, binding = 1) buffer specularCacheNormalMaterialBuffer
{
	vec4 specularCacheNormalMaterial[];
};

layout(std430, binding = 2) buffer cacheCommandBuffer
{
	DrawArraysInstanced command;
};

layout(local_size_x = WORKGROUPSIZE) in;

void main()
{
	uint idx = gl_GlobalInvocationID.x;

	uint cacheNumber = uint(imageLoad(cacheOffsetSampler, ivec2(width - 1, height - 1)).r);
	
	if(idx == 0)
	{
		command.count = cacheNumber;
	}
	
	const uint pixelNumber = width * height;
	uint pixelPerThread = uint(ceil(float(pixelNumber) / float(WORKGROUPSIZE * gl_NumWorkGroups.x)));
	const uint pixelOffset = idx * pixelPerThread;
	const uint pixelEnd = pixelOffset + pixelPerThread;
	
	for(uint i = pixelOffset; i < pixelEnd; i++)
	{
		if(i >= pixelNumber)
		{
			return;
		}
	
		ivec2 texCoord = ivec2(mod(i, width), i / width);
		vec2 texCoordNormalized = vec2(texCoord.x / float(width), texCoord.y / float(height));
		
		float samplingDistance = imageLoad(cacheSampleDistanceSampler, texCoord).r;
		
		if(samplingDistance == 0.0)
		{
			continue;
		}
		
		vec4 cachePosition = vec4(texCoordNormalized, texture(gBufferDepthSampler, texCoordNormalized).r, 1.0);
		cachePosition.xyz = cachePosition.xyz * 2.0 - 1.0;
		
		cachePosition = invViewProjectionMatrix * cachePosition;
		cachePosition.xyz /= cachePosition.w;

		uint cacheOffset = uint(imageLoad(cacheOffsetSampler, texCoord).r) - 1;
		
		specularCachePositions[cacheOffset] = vec4(cachePosition.xyz, samplingDistance);
		specularCacheNormalMaterial[cacheOffset] = vec4(encodeNormal(normalize(texture(gBufferNormalSampler, texCoordNormalized).xyz * 2.0 - 1.0)), texture(gBufferMaterialSampler, texCoordNormalized).ga);
	}
}