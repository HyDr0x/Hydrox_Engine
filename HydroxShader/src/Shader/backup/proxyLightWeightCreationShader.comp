#version 440 core

#define AREAARRAYSIZE 25
#define SAMPLENUMBER
#define KCACHE
#define PI 3.14159265359
#define EPSILON 0.00001
#define INT32_MAX 2147483647
#define WORKGROUPSIZE 128

#include "../../../../include/Shader/Shaderincludes/LightData.glslh"
#include "../../../../include/Shader/Shaderincludes/IndirectLightData.glslh"
#include "../../../../include/Shader/Shaderincludes/CacheData.glslh"
#include "../../../../include/Shader/Shaderincludes/CameraUBO.glslh"
#include "../../../../include/Shader/Shaderincludes/Encodings.glslh"

layout(std430, binding = 1) buffer samplingPattern
{
	vec4 samples[SAMPLENUMBER];
};

layout(location = 0) uniform sampler2DArray indirectLightPosLuminousFluxSampler;
layout(location = 1) uniform sampler2DArray indirectLightNormalAreaSampler;

layout(rgba32f, binding = 0) readonly uniform imageBuffer globalCachePositionBuffer;
layout(rgba32f, binding = 1) readonly uniform imageBuffer globalCacheNormalBuffer;

coherent layout(rgba32f, binding = 3) uniform image2D proxyLightPositionBuffer;
coherent layout(rgba32f, binding = 4) uniform image2D proxyLightLuminousFluxBuffer;

layout(location = 2) uniform sampler2D zBuffer;

layout(location = 3) uniform uint reflectiveShadowMapNumber;

layout(location = 4) uniform uint cacheNumber;

layout(location = 5) uniform uint proxyLightTextureResolution;

layout(location = 6) uniform uint globalVALOffset;

layout(local_size_x = WORKGROUPSIZE) in;

void main()
{
	uint idx = gl_GlobalInvocationID.x;

	uint cachesPerThread = uint(ceil(float(cacheNumber) / float(WORKGROUPSIZE * gl_NumWorkGroups.x)));
	uint cacheOffset = idx * cachesPerThread;
	
	if(cacheOffset >= cacheNumber)
	{
		return;
	}
	
	for(uint i = 0; i < cachesPerThread; i++)
	{
		uint cacheIndex = i + cacheOffset;
		ivec2 texCoord = ivec2(mod(cacheIndex, proxyLightTextureResolution), cacheIndex / proxyLightTextureResolution);
	
		if(texelFetch(zBuffer, texCoord, 0).r == 0) //discard the indirect lighting where the cache is being occluded
		{
			continue;
		}

		vec4 XpdW = imageLoad(proxyLightPositionBuffer, ivec2(2 * texCoord.x, texCoord.y));
		vec4 XpgW = imageLoad(proxyLightPositionBuffer, ivec2(2 * texCoord.x + 1, texCoord.y));
		
		vec3 Lod = imageLoad(proxyLightLuminousFluxBuffer, ivec2(2 * texCoord.x, texCoord.y)).rgb, Xpd = XpdW.xyz;
		vec3 Log = imageLoad(proxyLightLuminousFluxBuffer, ivec2(2 * texCoord.x + 1, texCoord.y)).rgb, Xpg = XpgW.xyz;
		
		float Wgesd = XpdW.w;
		float Wgesg = XpgW.w;

		CacheData cache;
		cache.position = imageLoad(globalCachePositionBuffer, int(cacheIndex));
		vec4 cacheNormalMaterialData = imageLoad(globalCacheNormalBuffer, int(cacheIndex));
		cache.normal.xyz = normalize(decodeNormal(cacheNormalMaterialData.xy));
		
		float frd = cache.position.w / PI;
		float frg = cacheNormalMaterialData.z * (cacheNormalMaterialData.w + 2.0) / (2.0 * PI);
		
		vec3 camDir = normalize(eyePos.xyz - cache.position.xyz);

		uint validVALNumber = min(globalVALOffset + KCACHE, SAMPLENUMBER);
		
		for(uint k = 0; k < reflectiveShadowMapNumber; k++)
		{
			float validLightSamples = 0.0;
			
			for(uint j = globalVALOffset; j < validVALNumber; j++)
			{
				vec3 texCoords;
				texCoords.x = 0.5 + samples[j].x;
				texCoords.y = 0.5 + samples[j].y;
				texCoords.z = float(k) / float(reflectiveShadowMapNumber);
			
				vec4 lightPos = texture(indirectLightPosLuminousFluxSampler, texCoords, 0);
				
				if(lightPos.w == 0.0) //cancels indirect lightsources which aren't initialized, because there is no geometry behind or lit
				{
					continue;
				}

				validLightSamples++;
				
				vec3 luminousFlux = unpackLuminousFlux(lightPos.w);
				
				vec4 lightNormalArea = texture(indirectLightNormalAreaSampler, texCoords, 0);
				
				vec3 lightNormal = normalize(lightNormalArea.xyz * 2.0 - 1.0);
				float lightArea = lightNormalArea.w;
				
				vec3 lightDir = lightPos.xyz - cache.position.xyz;
				float quadDistance = dot(lightDir, lightDir);
				lightDir = normalize(lightDir);
				
				float reflAngle = pow(max(dot(reflect(-lightDir, cache.normal.xyz), camDir), 0.0), cacheNormalMaterialData.w);
				//vec3 halfVector = (lightDir + camDir) / length(lightDir + camDir);
				//float reflAngle = max(pow(dot(halfVector, cache.normal.xyz), cacheNormalMaterialData.w), 0.00001);
				
				float F = (max(dot(lightNormal.xyz, normalize(cache.position.xyz - lightPos.xyz)), 0.0) * max(dot(cache.normal.xyz, lightDir), 0.0)) / (lightArea + PI * quadDistance);
				
				float Wd = F;
				float Wg = reflAngle * F;
				
				Xpd += Wd * lightPos.xyz;
				Xpg += Wg * lightPos.xyz;
				
				Lod += luminousFlux * frd * F;
				Log += luminousFlux * frg * reflAngle * F;
				
				Wgesd += Wd;
				Wgesg += Wg;
			}
			
			if(validLightSamples > 0)
			{
				Lod *= (float(validVALNumber - globalVALOffset) / validLightSamples);
				Log *= (float(validVALNumber - globalVALOffset) / validLightSamples);
			}
		}
		
		imageStore(proxyLightLuminousFluxBuffer, ivec2(2 * texCoord.x, texCoord.y), vec4(Lod, 0));
		imageStore(proxyLightLuminousFluxBuffer, ivec2(2 * texCoord.x + 1, texCoord.y), vec4(Log, 0));
		
		imageStore(proxyLightPositionBuffer, ivec2(2 * texCoord.x, texCoord.y), vec4(Xpd, Wgesd));
		imageStore(proxyLightPositionBuffer, ivec2(2 * texCoord.x + 1, texCoord.y), vec4(Xpg, Wgesg));
	}
}