#version 440 core

#define WORKGROUPSIZE 128
#define PI 3.14159265359f
#define Ep 0.0001f

#include "../../../include/Shader/LightData.glslh"
#include "../../../include/Shader/IndirectLightData.glslh"
#include "../../../include/Shader/CacheData.glslh"
#include "../../../include/Shader/CameraUBO.glslh"
#include "../../../include/Shader/Encodings.glslh"

layout(location = 0) uniform sampler2DArray indirectLightPosSampler;
layout(location = 1) uniform sampler2DArray indirectLightNormalSampler;
layout(location = 2) uniform sampler2DArray indirectLightLuminousFluxSampler;

layout(rgba32f, binding = 0) readonly uniform image2D globalCachePositionBuffer;
layout(rgba32f, binding = 1) readonly uniform image2D globalCacheNormalBuffer;

layout(rgba32f, binding = 2) writeonly uniform image2D indirectLightPositionBuffer;
layout(rgba32f, binding = 3) writeonly uniform image2D indirectLightNormalBuffer;

layout(r8, binding = 4) readonly uniform image2D zBuffer;

layout(location = 8) uniform uint indirectLightNumberXY;
layout(location = 9) uniform uint indirectLightNumberZ;

layout(location = 10) uniform uint cacheNumber;

layout(location = 11) uniform uint unusedLightNumber;

layout(location = 12) uniform uint bufferResolution;

layout(local_size_x = WORKGROUPSIZE) in;

void main()
{
	uint idx = gl_GlobalInvocationID.x;

	uint cachesPerThread = max(cacheNumber / (WORKGROUPSIZE * gl_NumWorkGroups.x), 1);
	uint cacheOffset = idx * cachesPerThread;
	
	if(cacheOffset >= cacheNumber)
	{
		return;
	}
	
	uint lightNumber = indirectLightNumberXY * indirectLightNumberXY * indirectLightNumberZ;
	
	for(uint i = 0; i < cachesPerThread; i++)
	{
		ivec2 cacheCoord = ivec2(mod(cacheOffset + i, bufferResolution), (cacheOffset + i) / bufferResolution);
		
		if(imageLoad(zBuffer, cacheCoord).x == 0)
		{
			continue;
		}
		
		vec3 Lod = vec3(0.0f), Xpd = vec3(0.0f);
		vec3 Log = vec3(0.0f), Xpg = vec3(0.0f);
		
		float Wgesd = 0.0f;
		float Wgesg = 0.0f;
		
		CacheData cache;
		cache.position = imageLoad(globalCachePositionBuffer, cacheCoord);
		cache.normal = imageLoad(globalCacheNormalBuffer, cacheCoord);
		
		float frd = cache.position.w / PI;
		float frg = cache.normal.z * (cache.normal.w + 8.0f) / (8.0f * PI);
		
		vec3 camDir = normalize(eyePos.xyz - cache.position.xyz);
		
		vec3 cacheNormal = normalize(decodeNormal(cache.normal.xy));
		
		for(uint j = 0; j < lightNumber; j += unusedLightNumber)
		{
			ivec3 texCoords;
			texCoords.x = int(j % indirectLightNumberXY);
			texCoords.y = int((j % (indirectLightNumberXY * indirectLightNumberXY)) / float(indirectLightNumberXY));
			texCoords.z = int(j / float(indirectLightNumberXY * indirectLightNumberXY));
			
			vec4 lightPos = texelFetch(indirectLightPosSampler, texCoords, 0);
			
			if(lightPos.w == 0.0f) continue;
			
			vec4 lightNormalArea = texelFetch(indirectLightNormalSampler, texCoords, 0);
			
			vec3 lightNormal = normalize(lightNormalArea.xyz * 2.0f - 1.0f);
			float lightArea = lightNormalArea.w;
			
			vec3 luminousFlux = texelFetch(indirectLightLuminousFluxSampler, texCoords, 0).rgb;
			
			vec3 lightDir = lightPos.xyz - cache.position.xyz;
			float quadDistance = dot(lightDir, lightDir);
			lightDir = normalize(lightDir);
			
			float reflAngle = max(pow(dot(reflect(-lightDir, cacheNormal), camDir), cache.normal.w), 0.00001f);
			//vec3 halfVector = (lightDir + camDir) / length(lightDir + camDir);
			//float reflAngle = max(pow(dot(halfVector, cacheNormal), cache.normal.w), 0.00001f);
		
			float F = max(dot(lightNormal.xyz, normalize(cache.position.xyz - lightPos.xyz)) * dot(cacheNormal, lightDir), 0) / (lightArea + PI * quadDistance);
			
			float Wd = Ep + F;
			float Wg = Ep + reflAngle * F;
			
			Xpd += Wd * lightPos.xyz;
			Xpg += Wg * lightPos.xyz;
			
			Lod += luminousFlux * frd * F;
			Log += luminousFlux * frg * reflAngle * F;
			
			Wgesd += Wd;
			Wgesg += Wg;
		}
		
		Xpd /= Wgesd;
		Xpg /= Wgesg;
		
		vec3 lightDirD = Xpd - cache.position.xyz;
		float lightAngleD = max(dot(cacheNormal, normalize(lightDirD)), 0.1f);

		imageStore(indirectLightPositionBuffer, ivec2(2 * cacheCoord.x, cacheCoord.y), vec4(Xpd, 0));
		imageStore(indirectLightNormalBuffer, ivec2(2 * cacheCoord.x, cacheCoord.y), vec4((4.0f * PI * Lod * dot(lightDirD, lightDirD)) / (frd * lightAngleD), 0));
		
		vec3 lightDirG = Xpg - cache.position.xyz;
		float lightQuadDistance = dot(lightDirG, lightDirG);
		lightDirG = normalize(lightDirG);
		float reflAngleG = max(pow(dot(reflect(-lightDirG, cacheNormal), camDir), cache.normal.w), 0.1f);
		//vec3 halfVector = (lightDirG + camDir) / length(lightDirG + camDir);
		//float reflAngleG = max(pow(dot(halfVector, cacheNormal), cache.normal.w), 0.1f);
		float lightAngleG = max(dot(lightDirG, cacheNormal), 0.1f);
		
		imageStore(indirectLightPositionBuffer, ivec2(2 * cacheCoord.x + 1, cacheCoord.y), vec4(Xpg, 0));
		imageStore(indirectLightNormalBuffer, ivec2(2 * cacheCoord.x + 1, cacheCoord.y), vec4((4.0f * PI * Log * lightQuadDistance) / (frg * reflAngleG * lightAngleG), 0));
	}
}