//encode the z-component as the length of the 2D normal, to be able to decode the normalized direction with only two components
vec2 encodeNormal(in vec3 normal)
{
	return normal.z < 1.0 - 0.00001 ? (normal.z * 0.5 + 0.5) * normalize(normal.xy + 0.00001) : vec2(1.0, 0.0f);
}

vec3 decodeNormal(in vec2 normal)
{
	float z = length(normal) * 2.0 - 1.0;
	return z > -1.0 + 0.00001 ? vec3(sqrt((1.0 - z * z) / (dot(normal, normal) + 0.00001)) * normal, z) : vec3(0.0, 0.0, -1.0);
}

float packLuminousFlux(in vec3 val)
{
	return uint(round(val.r * 1023.0) + round(val.g * 1023.0) * 1024.0 + round(val.b * 1023.0) * 1048576.0);
}

vec3 unpackLuminousFlux(in float val)
{
	vec3 result;
	result.b = round(val / 1048576);
	result.g = round((val - result.b * 1048576.0) / 1024);
	result.r = round(val - result.b * 1048576.0 - result.g * 1024.0);
	
	return result / 1023.0;
}