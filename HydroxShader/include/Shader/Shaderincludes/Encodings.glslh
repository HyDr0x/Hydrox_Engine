//encode the z-component as the length of the 2D normal, to be able to decode the normalized direction with only two components
vec2 encodeNormal(in vec3 normal)
{
	return normal.z < 1.0 - 0.00001 ? (normal.z * 0.5 + 0.5) * normalize(normal.xy + 0.00001) : vec2(1.0, 0.0f);
}

vec3 decodeNormal(in vec2 normal)
{
	float z = length(normal) * 2.0 - 1.0;
	return z > -1.0 + 0.00001 ? vec3(sqrt((1.0 - z * z) / (dot(normal, normal) + 0.00001)) * normal, z) : vec3(0.0, 0.0, -1.0);
}

float packLuminousFlux(in vec3 val)
{
	float result = (floor(val.r * 255.0) + floor(val.g * 255.0) * 256 + floor(val.b * 255.0) * 65536);
	
	return result;
}

vec3 unpackLuminousFlux(in float val)
{
	//val *= 16777215.0;
	vec3 result;
	result.b = floor(val / 65536.0);
	result.g = floor((val - result.b * 65536.0) / 256.0);
	result.r = floor(val - result.b * 65536.0 - result.g * 256.0);
	
	return result / 255.0;
}