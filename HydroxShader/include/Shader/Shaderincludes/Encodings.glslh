//encode the z-component as the length of the 2D normal, to be able to decode the normalized direction with only two components
vec2 encodeNormal(in vec3 normal)
{
	return normal.z < 1.0 - 0.00001 ? (normal.z * 0.5 + 0.5) * normalize(normal.xy + 0.00001) : vec2(1.0, 0.0f);
}

vec3 decodeNormal(in vec2 normal)
{
	float z = length(normal) * 2.0 - 1.0;
	return z > -1.0 + 0.00001 ? vec3(sqrt((1.0 - z * z) / (dot(normal, normal) + 0.00001)) * normal, z) : vec3(0.0, 0.0, -1.0);
}

float packLuminousFlux(in vec3 val)
{
	return uint(round(val.r * 1023.0) + round(val.g * 1023.0) * 1024.0 + round(val.b * 1023.0) * 1048576.0);
}

vec3 unpackLuminousFlux(in float val)
{
	vec3 result;
	result.b = round(val / 1048576);
	result.g = round((val - result.b * 1048576.0) / 1024);
	result.r = round(val - result.b * 1048576.0 - result.g * 1024.0);
	
	return result / 1023.0;
}
/*
he::util::vec2f packLuminousFluxHigh(he::util::vec3f val)
{
  unsigned int tmp0 = unsigned int(val[0] * 2097151.0f + 0.5f);//upper bitmask: 4292870144 | lower bitmask: 2097151
  unsigned int tmp1 = unsigned int(val[1] * 2097151.0f + 0.5f);
  unsigned int tmp2 = unsigned int(val[2] * 2097151.0f + 0.5f);
  
  he::util::vec2f result;
  result[0] = tmp0 | (tmp1 << 21);
  result[1] = tmp1 >> 11 | tmp2 << 10;
  return result;
}

he::util::vec3f unpackLuminousFluxHigh(he::util::vec2f val)
{
  he::util::vec2ui newVal = he::util::math::vector_cast<unsigned int>(val);
  he::util::vec3f result;
  result[0] = newVal[0] & 2097151;
  result[1] = ((newVal[1] & 2047) << 11) | ((newVal[0] & 4292870144) >> 21);
  result[2] = newVal[1] >> 10;

  return result / 2097151.0f;
}*/