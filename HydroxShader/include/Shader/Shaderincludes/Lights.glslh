#define PI 3.14159265359f

#include "LightData.glslh"

float calculateBRDF(in vec3 camDir, in vec3 lightDir, in vec3 normal, in float diffuseRho, in float specularRho, in float roughness)
{
	float diffuse = diffuseRho / PI;
	
	//vec3 reflectRay = reflect(-lightDir, normal);
	//float specular = ((roughness + 2.0f) / (2.0f * PI)) * specularRho * pow(max(dot(reflectRay, camDir), 0.0f), roughness);
	
	vec3 halfVector = (lightDir + camDir) / length(lightDir + camDir);
	float specular = ((roughness + 8.0f) / (8.0f * PI)) * specularRho * pow(max(dot(halfVector, normal), 0.0f), roughness);
	
	return diffuse + specular;
}

float calculateLuminance(LightData light, const vec3 worldPos, const vec3 normal, const vec4 material)
{
	vec3 lightDir;
	float attenuation, omega;
	
	lightDir = light.position.xyz - worldPos;
	float distance = length(lightDir);
	lightDir = normalize(lightDir);
	omega = max(dot(lightDir, normal), 0.0f);
	
	attenuation = 1.0f /(light.constAttenuation + light.linearAttenuation * distance + light.quadricAttenuation * distance * distance);

	if(light.position.x == DIRECTIONAL_LIGHT_POSITION)//DIRECTIONAL LIGHT
	{
		lightDir = normalize(light.direction.xyz);
		omega = max(dot(lightDir, normal), 0.0f);
		
		attenuation /= (light.projectionParameter.z * light.projectionParameter.w);//divide through the area of the near clipping plane, from where the directional light beams come from
	}
	else//SPOTLIGHT
	{
		float spotLightAngle = max(dot(lightDir, normalize(light.direction.xyz)), 0.0f);
		//float spotAttenuation = step(light.direction.w, spotLightAngle) * clamp(pow(spotLightAngle, light.position.w), 0.0f, 1.0f);
		float spotAttenuation = clamp((spotLightAngle - light.direction.w) * 1.0 / 0.05, 0.0, 1.0) * clamp(pow(spotLightAngle, light.position.w), 0.0f, 1.0f);
		
		attenuation *= spotAttenuation;
	}
	
	float brdf = calculateBRDF(normalize(eyePos.xyz - worldPos), lightDir, normal, material.x, material.y, material.w);
	
	return attenuation * light.luminousFlux * omega * brdf;
}
