#define PI 3.14159265359f

#include "LightData.glslh"

float calculateBRDF(in vec3 camDir, in vec3 lightDir, in vec3 normal, in float diffuseRho, in float specularRho, in float roughness)
{
	float diffuse = diffuseRho / PI;
	
	//vec3 reflectRay = reflect(-lightDir, normal);
	//float specular = ((roughness + 2.0f) / (2.0f * PI)) * specularRho * pow(max(dot(reflectRay, camDir), 0.0f), roughness);
	
	vec3 halfVector = (lightDir + camDir) / length(lightDir + camDir);
	float specular = ((roughness + 8.0f) / (8.0f * PI)) * specularRho * pow(max(dot(halfVector, normal), 0.0f), roughness);
	
	return diffuse + specular;
}

float calculateLuminance(LightData light, const vec3 worldPos, const vec3 normal, const vec4 material)
{
	if(light.position.x == DIRECTIONAL_LIGHT_POSITION)//DIRECTIONAL LIGHT
	{
		vec3 lightDir = normalize(light.direction.xyz);
		float omega = max(dot(lightDir, normal), 0.0f);
		
		float brdf = calculateBRDF(normalize(eyePos.xyz - worldPos), lightDir, normal, material.x, material.y, material.w);
		
		return (light.luminousFlux * omega * brdf) / (light.projectionParameter.z * light.projectionParameter.w);//divide through the area of the near clipping plane, from where the directional light beams come from
	}
	else if(light.direction.xyz == vec3(0.0f))//POINTLIGHT
	{
		vec3 lightDir = light.position.xyz - worldPos;
		float distance = length(lightDir);
		lightDir = normalize(lightDir);
		float omega = max(dot(lightDir, normal), 0.0f);
		
		float brdf = calculateBRDF(normalize(eyePos.xyz - worldPos), lightDir, normal, material.x, material.y, material.w);
		
		float attenuation = 1.0f /(light.constAttenuation + light.linearAttenuation * distance + light.quadricAttenuation * distance * distance);
		
		return attenuation * light.luminousFlux * omega * brdf;
	}
	else//SPOTLIGHT
	{
		vec3 lightDir = light.position.xyz - worldPos;
		float distance = length(lightDir);
		lightDir = normalize(lightDir);
		float omega = max(dot(lightDir, normal), 0.0f);
		
		float brdf = calculateBRDF(normalize(eyePos.xyz - worldPos), lightDir, normal, material.x, material.y, material.w);
		
		float attenuation = 1.0f / (light.constAttenuation + light.linearAttenuation * distance + light.quadricAttenuation * distance * distance);
		float spotLightAngle = max(dot(lightDir, normalize(light.direction.xyz)), 0.0f);
		float spotAttenuation = step(light.direction.w, spotLightAngle) * clamp(pow(spotLightAngle, light.position.w), 0.0f, 1.0f);
		
		return spotAttenuation * attenuation * light.luminousFlux * omega * brdf;
	}
}
