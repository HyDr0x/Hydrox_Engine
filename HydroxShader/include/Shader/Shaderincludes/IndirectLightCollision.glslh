layout(std430, binding = LIGHTTUBEBINDINGPOINT) buffer tubeData
{
	vec4 tubeStartPosRadius[1];
	vec4 tubeDirection[1];//not normalized, the vector length is the length of the tube
};

float specularCacheSolidAngle(float yFuncOffset, float n)
{
	//return PI_HALF - asin(pow(yFuncOffset, 1.0 / n));
	return acos(pow(yFuncOffset, 1.0 / n));
	//return acos(pow((yFuncOffset * 2.0 * PI) / (2.0 + n), 1.0 / n));
}

bool indirectLightTubeCollision(in vec3 cachePos, in vec3 r, in float maxSolidAngle, in uint tubeIndex, out float distance)
{
	float dotRDir = dot(r, tubeDirection[tubeIndex].xyz);
	
	vec3 trfTubeStartPos = tubeStartPosRadius[tubeIndex].xyz - cachePos;
	
	float divisor = dot(tubeDirection[tubeIndex].xyz, tubeDirection[tubeIndex].xyz) - dotRDir * dotRDir;
	float t = divisor != 0.0 ? (dot(r, trfTubeStartPos) * dotRDir - dot(trfTubeStartPos, tubeDirection[tubeIndex].xyz)) / divisor : 0.0;
	vec3 tubePosAngleTest = trfTubeStartPos + t * tubeDirection[tubeIndex].xyz;
	
	if(dot(tubePosAngleTest, r) < 0.0)
	{
		t = dot(r, tubeDirection[tubeIndex].xyz) > 0.0 ? 1.0 : 0.0;
	}
	
	vec3 tubePos = trfTubeStartPos + clamp(t, 0.0, 1.0) * tubeDirection[tubeIndex].xyz;
	
	float lineDistance = length(tubePos);

	float radius = tubeStartPosRadius[tubeIndex].w;
	
	vec3 centerToRay = max(dot(tubePos, r), 0.0) * r - tubePos;
	//vec3 closestPoint = (tubePos + centerToRay * clamp(radius / length(centerToRay), 0.0, 1.0));
	
	float dist = lineDistance * lineDistance - radius * radius;

	if(dist <= 0.0 || length(centerToRay) < radius)
	{
		distance = lineDistance;
		return true;
	}
	
	dist = sqrt(dist);
	vec3 Ntangent = normalize(cross(tubePos, r));
	
	float linDist = radius / dist;
	
	mat3 linearSystem = mat3(1.0, 1.0, 1.0,
													 linDist * Ntangent.z, linDist * Ntangent.x, linDist * Ntangent.y,
													 -linDist * Ntangent.y, -linDist * Ntangent.z, -linDist * Ntangent.x);//column major order
										
	vec3 tangentPoint = inverse(linearSystem) * tubePos;
	vec3 closestPoint = tubePos + normalize(tangentPoint - tubePos) * radius;
	
	vec3 tangentLotPoint = dot(normalize(tubePos), tangentPoint) * normalize(tubePos);
	vec3 mirroredTangentPoint = 2.0 * tangentLotPoint - tangentPoint;
	vec3 mirroredClosestPoint = tubePos + normalize(mirroredTangentPoint - tubePos) * radius;

	float beta = max(dot(normalize(mirroredClosestPoint), r), dot(normalize(closestPoint), r));
	
	/*
	mat3 linearSystem = mat3(-radius, -dist * Ntangent.z, dist * Ntangent.y,
													 dist * Ntangent.z, -radius, -dist * Ntangent.x,
													 -dist * Ntangent.y, dist * Ntangent.x, -radius);//column major order
										
	vec3 closestPoint = tubePos + normalize(inverse(linearSystem) * tubePos) * radius;*/
	
	
	float tubeDistance = max(length(closestPoint), 0.001);

	//if we are inside the tube, we use the distance to the center
	distance = lineDistance < tubeStartPosRadius[tubeIndex].w ? length(tubePos + 0.5 * tubeDirection[tubeIndex].xyz) : tubeDistance;
	//distance = lineDistance;
	//distance = tubeDistance;
	//distance = length(cachePos - (trfTubeStartPos + 0.5 * tubeDirection[tubeIndex].xyz));
	
	float radix = 2.0;
	float base = pow(radix, floor(log(distance) / log(radix)) - 1.0);
	distance = base * floor(distance / base);

	return beta > cos(maxSolidAngle);
}

float samplingDistance(float lightDistance, float maxSolidAngle)
{
	//float openingAngle = 2.0 * acos(1.0 - maxSolidAngle / (2.0 * PI));
	return max(lightDistance * tan(maxSolidAngle), 0.01);
	//return max(1.0 * tan(maxSolidAngle), 0.01) * 0.1;
}